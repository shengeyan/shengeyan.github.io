<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java稿</title>
      <link href="/shengeyan/2023/03161.html"/>
      <url>/shengeyan/2023/03161.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>语法：printf print println</p><p>PS：</p><ul><li>println 会输出后换行</li><li>printf 类似于c语言printf</li></ul><h1 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h1><h2 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.hp.date;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class CalendarDemo&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //获取获取系统的当前日历对象</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        //1、获取今天是周几</span><br><span class="line">        int weekDay = instance.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        System.out.println(&quot;今天是周:&quot; + (weekDay - 1));</span><br><span class="line"></span><br><span class="line">        //2、获取系统当前年</span><br><span class="line">        int year = instance.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(&quot;今年是:&quot; + year + &quot;年&quot;);</span><br><span class="line"></span><br><span class="line">        //3、获取系统当前月</span><br><span class="line">        int month = instance.get(Calendar.MONTH);</span><br><span class="line">        System.out.println(&quot;本月是:&quot; + (month + 1) + &quot;月&quot;);</span><br><span class="line"></span><br><span class="line">        //4、获取系统当前日</span><br><span class="line">        int day = instance.get(Calendar.DATE);</span><br><span class="line">        System.out.println(&quot;今天是&quot; + day + &quot;号&quot;);</span><br><span class="line"></span><br><span class="line">        //5、获取上午跟下午</span><br><span class="line">        int am_pm = instance.get(Calendar.AM_PM);</span><br><span class="line">        if (am_pm == 0)</span><br><span class="line">            System.out.println(&quot;是上午&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;是下午&quot;);</span><br><span class="line"></span><br><span class="line">        //6、获取当前的系统时间[date--&gt;String]的过程</span><br><span class="line">        Date time = instance.getTime();//获取的是当前系统的时间</span><br><span class="line">        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);</span><br><span class="line">        String showTime = format.format(time);</span><br><span class="line">        System.out.println(&quot;当前系统时间为：&quot; + showTime);</span><br><span class="line"></span><br><span class="line">        //7、自定义日历的时间</span><br><span class="line">        String strTime = &quot;2021-07-07&quot;;</span><br><span class="line">        Date date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(strTime);</span><br><span class="line">        instance.setTime(date);//将时间对象data设置为新的日历</span><br><span class="line">        System.out.println(&quot;修改后的系统时间为：&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(instance.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  System.out.println(&quot;------------Calendar和Date转换------------&quot;);</span><br><span class="line">        Date now = calendar.getTime();</span><br><span class="line">        calendar.setTime(now);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;------------Calendar日期计算以及判断------------&quot;);</span><br><span class="line">        calendar = new GregorianCalendar();</span><br><span class="line">        Calendar calendar2 = new GregorianCalendar();</span><br><span class="line">        calendar2.set(Calendar.YEAR, 2800);</span><br><span class="line">        //是否在某个时间(calendar2)之后</span><br><span class="line">        System.out.println(calendar.after(calendar2));</span><br><span class="line">        //是否在某个时间(calendar2)之前</span><br><span class="line">        System.out.println(calendar.before(calendar2));</span><br><span class="line">        //增加多少年年，月日以及时分秒同理</span><br><span class="line">        calendar.add(Calendar.YEAR, -10);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(原数组，开始位置，目标数组，开始位置，复制长度)</span><br></pre></td></tr></table></figure><h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS稿</title>
      <link href="/shengeyan/2023/030252486.html"/>
      <url>/shengeyan/2023/030252486.html</url>
      
        <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>​    将数组，对象拆分，将需要的数据传递给变量</p><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><hr><p>​    eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 我们有一个存放了名字和姓氏的数组</span><br><span class="line">let arr = [&quot;John&quot;, &quot;Smith&quot;]</span><br><span class="line"></span><br><span class="line">// 解构赋值</span><br><span class="line">// 设置 firstName = arr[0]</span><br><span class="line">// 以及 surname = arr[1]</span><br><span class="line">let [firstName, surname] = arr;</span><br><span class="line"></span><br><span class="line">alert(firstName); // John</span><br><span class="line">alert(surname);  // Smith</span><br></pre></td></tr></table></figure><p>(结合split函数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [firstName, surname] = &quot;John Smith&quot;.split(&#x27; &#x27;);</span><br><span class="line">alert(firstName); // John</span><br><span class="line">alert(surname);  // Smith</span><br></pre></td></tr></table></figure><h5 id="逗号解构"><a href="#逗号解构" class="headerlink" title="逗号解构"></a>逗号解构</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不需要第二个元素</span><br><span class="line">let [firstName, , title] = [&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;of the Roman Republic&quot;];</span><br><span class="line"></span><br><span class="line">alert( title ); // Consul</span><br></pre></td></tr></table></figure><p>解释：忽略逗号之间的元素</p><h5 id="等号结构"><a href="#等号结构" class="headerlink" title="等号结构"></a>等号结构</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] = &quot;abc&quot;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">let [one, two, three] = new Set([1, 2, 3]);</span><br></pre></td></tr></table></figure><p>解释：应用等号，可以将可迭代对象或数组赋值给白能量</p><h5 id="等号左侧赋值"><a href="#等号左侧赋值" class="headerlink" title="等号左侧赋值"></a>等号左侧赋值</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;&#125;;</span><br><span class="line">[user.name, user.surname] = &quot;John Smith&quot;.split(&#x27; &#x27;);</span><br><span class="line"></span><br><span class="line">alert(user.name); // John</span><br><span class="line">alert(user.surname); // Smith</span><br></pre></td></tr></table></figure><p>解释：等号左侧为可赋值变量均可被赋值</p><h5 id="entries（）方法循环"><a href="#entries（）方法循环" class="headerlink" title="entries（）方法循环"></a>entries（）方法循环</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用循环遍历键—值对</span><br><span class="line">for (let [key, value] of Object.entries(user)) &#123;</span><br><span class="line">  alert(`$&#123;key&#125;:$&#123;value&#125;`); // name:John, then age:30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：object.entries（）创建，然后通过键值对进行循环</p><h5 id="”…“结构"><a href="#”…“结构" class="headerlink" title="”…“结构"></a>”…“结构</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [name1, name2, ...rest] = [&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;of the Roman Republic&quot;];</span><br><span class="line"></span><br><span class="line">// rest 是包含从第三项开始的其余数组项的数组</span><br><span class="line">alert(rest[0]); // Consul</span><br><span class="line">alert(rest[1]); // of the Roman Republic</span><br><span class="line">alert(rest.length); // 2</span><br></pre></td></tr></table></figure><p>解释：进行不同块的赋值，…后的数据放入name新数组中存放</p><h5 id="交换技巧"><a href="#交换技巧" class="headerlink" title="交换技巧"></a>交换技巧</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let guest = &quot;Jane&quot;;</span><br><span class="line">let admin = &quot;Pete&quot;;</span><br><span class="line"></span><br><span class="line">// 让我们来交换变量的值：使得 guest = Pete，admin = Jane</span><br><span class="line">[guest, admin] = [admin, guest];</span><br><span class="line"></span><br><span class="line">alert(`$&#123;guest&#125; $&#123;admin&#125;`); // Pete Jane（成功交换！）</span><br></pre></td></tr></table></figure><p>解释：类似于变量交换，省略第三个变量</p><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 默认值</span><br><span class="line">let [name = &quot;Guest&quot;, surname = &quot;Anonymous&quot;] = [&quot;Julius&quot;];</span><br><span class="line"></span><br><span class="line">alert(name);    // Julius（来自数组的值）</span><br><span class="line">alert(surname); // Anonymous（默认值被使用了）</span><br></pre></td></tr></table></figure><p>解释：在赋值前，提前给变量进行初始赋值，赋值可以为函数</p><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><hr><p>​    数组的结构同样适用于对象结构</p><h5 id="冒号-”：“"><a href="#冒号-”：“" class="headerlink" title="冒号 ”：“"></a>冒号 ”：“</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let options = &#123;</span><br><span class="line">  title: &quot;Menu&quot;,</span><br><span class="line">  width: 100,</span><br><span class="line">  height: 200</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// &#123; sourceProperty: targetVariable &#125;</span><br><span class="line">let &#123;width: w, height: h, title&#125; = options;</span><br><span class="line"></span><br><span class="line">// width -&gt; w</span><br><span class="line">// height -&gt; h</span><br><span class="line">// title -&gt; title</span><br><span class="line"></span><br><span class="line">alert(title);  // Menu</span><br><span class="line">alert(w);      // 100</span><br><span class="line">alert(h);      // 200</span><br></pre></td></tr></table></figure><p>解释：左：右  冒号结构，在对象中是将左侧属性的值赋给右侧变量，方向为左到右</p><p>PS：可结合 = 进行默认值设置</p><h5 id="剩余模式“…”"><a href="#剩余模式“…”" class="headerlink" title="剩余模式“…”"></a>剩余模式“…”</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let options = &#123;</span><br><span class="line">  title: &quot;Menu&quot;,</span><br><span class="line">  height: 200,</span><br><span class="line">  width: 100</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// title = 名为 title 的属性</span><br><span class="line">// rest = 存有剩余属性的对象</span><br><span class="line">let &#123;title, ...rest&#125; = options;</span><br><span class="line"></span><br><span class="line">// 现在 title=&quot;Menu&quot;, rest=&#123;height: 200, width: 100&#125;</span><br><span class="line">alert(rest.height);  // 200</span><br><span class="line">alert(rest.width);   // 100</span><br></pre></td></tr></table></figure><p>解释：类似于数组的结构，将不用的数据存放在…name 的对象中</p><p>PS:</p><h5 id="let-的错误语法"><a href="#let-的错误语法" class="headerlink" title="let 的错误语法"></a>let 的错误语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">et title, width, height;</span><br><span class="line"></span><br><span class="line">// 这一行发生了错误</span><br><span class="line">&#123;title, width, height&#125; = &#123;title: &quot;Menu&quot;, width: 200, height: 100&#125;;</span><br><span class="line"></span><br><span class="line">// 修改：</span><br><span class="line">(&#123;title, width, height&#125; = &#123;title: &quot;Menu&quot;, width: 200, height: 100&#125;);</span><br></pre></td></tr></table></figure><p>解释：对整个用括号包起来，取消代码块，防止JS误认为代码块</p><h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><hr><p>​    嵌套为含有对象，数组，键值等不同的数据解构的情况</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let options = &#123;</span><br><span class="line">  size: &#123;</span><br><span class="line">    width: 100,</span><br><span class="line">    height: 200</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [&quot;Cake&quot;, &quot;Donut&quot;],</span><br><span class="line">  extra: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 为了清晰起见，解构赋值语句被写成多行的形式</span><br><span class="line">let &#123;</span><br><span class="line">  size: &#123; // 把 size 赋值到这里</span><br><span class="line">    width,</span><br><span class="line">    height</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [item1, item2], // 把 items 赋值到这里</span><br><span class="line">  title = &quot;Menu&quot; // 在对象中不存在（使用默认值）</span><br><span class="line">&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  // Menu</span><br><span class="line">alert(width);  // 100</span><br><span class="line">alert(height); // 200</span><br><span class="line">alert(item1);  // Cake</span><br><span class="line">alert(item2);  // Donut</span><br></pre></td></tr></table></figure><p>解释：形式对应赋值，不存在的值采用默认值形式</p><p>PS：size和items没有对应变量，因为取的为他们的内容</p><h4 id="智能函数参数"><a href="#智能函数参数" class="headerlink" title="智能函数参数"></a>智能函数参数</h4><hr><p>​    思想：将所有参数传递给对象，然后对对象进行解构</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let options = &#123;</span><br><span class="line">  title: &quot;My menu&quot;,</span><br><span class="line">  items: [&quot;Item1&quot;, &quot;Item2&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function showMenu(&#123;</span><br><span class="line">  title = &quot;Untitled&quot;,</span><br><span class="line">  width: w = 100,  // width goes to w</span><br><span class="line">  height: h = 200, // height goes to h</span><br><span class="line">  items: [item1, item2] // items first element goes to item1, second to item2</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  alert( `$&#123;title&#125; $&#123;w&#125; $&#123;h&#125;` ); // My Menu 100 200</span><br><span class="line">  alert( item1 ); // Item1</span><br><span class="line">  alert( item2 ); // Item2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMenu(options);</span><br></pre></td></tr></table></figure><p>解释：可以用冒号，等号联合使用</p><p>PS:</p><p>​    空对象的使用，在这种解构情况下，需要传递参数，如果想使用默认值则需要传递空对象</p><p>​    eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function showMenu(&#123; title = &quot;Menu&quot;, width = 100, height = 200 &#125; = &#123;&#125;) &#123;</span><br><span class="line">  alert( `$&#123;title&#125; $&#123;width&#125; $&#123;height&#125;` );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMenu(); // Menu 100 200</span><br></pre></td></tr></table></figure><p>或者 showMenu({ }) 则函数内参数不要{}</p><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>​    内建对象：日期（DATE）</p><p>​    日期不能更改</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>语法：可用 new Date（） 创建date对象</p><p>PS：</p><ul><li>不带参数 表示当前时间对象</li><li>milliseconds 整数参数 表示距1970 年 1 月 1 日 UTC+0 之后经过的毫秒数（1/1000 秒）</li><li>datestring 字符串参数 </li><li>new Date(year, month, date, hours, minutes, seconds, ms)</li></ul><p>PS:</p><ul><li><code>year</code> 应该是四位数。为了兼容性，也接受 2 位数，并将其视为 <code>19xx</code>，例如 <code>98</code> 与 <code>1998</code> 相同，但强烈建议始终使用 4 位数。</li><li><code>month</code> 计数从 <code>0</code>（一月）开始，到 <code>11</code>（十二月）结束。</li><li><code>date</code> 是当月的具体某一天，如果缺失，则为默认值 <code>1</code>。</li><li>如果 <code>hours/minutes/seconds/ms</code> 缺失，则均为默认值 <code>0</code>。</li></ul><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let date = new Date(2011, 0, 1, 2, 3, 4, 567);</span><br><span class="line">alert( date ); // 1.01.2011, 02:03:04.567</span><br></pre></td></tr></table></figure><h4 id="访问日期"><a href="#访问日期" class="headerlink" title="访问日期"></a>访问日期</h4><p>组件：</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear">getFullYear()</a></p><p>获取年份（4 位数）</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth">getMonth()</a></p><p>获取月份，<strong>从 0 到 11</strong>。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate">getDate()</a></p><p>获取当月的具体日期，从 1 到 31</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours">getHours()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes">getMinutes()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds">getSeconds()</a>，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds">getMilliseconds()</a></p><p>获取相应的时间组件 （分时秒毫秒）</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay">getDay()</a></p><p>获取一周中第几天，从0（星期日）到6（星期六）</p><p>PS: UTC 时间，在get后面加UTC即可  （国际时间）</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a></p><p>返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset">getTimezoneOffset()</a></p><p>返回 UTC 与本地时区之间的时差，以分钟为单位：</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ 如果你在时区 UTC-1，输出 60</span><br><span class="line">// 如果你在时区 UTC+3，输出 -180</span><br><span class="line">alert( new Date().getTimezoneOffset() );</span><br></pre></td></tr></table></figure><h4 id="设置日期"><a href="#设置日期" class="headerlink" title="设置日期"></a>设置日期</h4><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear"><code>setFullYear(year, [month], [date])</code></a></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth"><code>setMonth(month, [date])</code></a></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate"><code>setDate(date)</code></a></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours"><code>setHours(hour, [min], [sec], [ms])</code></a></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes"><code>setMinutes(min, [sec], [ms])</code></a></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds"><code>setSeconds(sec, [ms])</code></a></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds"><code>setMilliseconds(ms)</code></a></li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime"><code>setTime(milliseconds)</code></a>（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）</li><li>以上方法除了 <code>setTime()</code> 都有 UTC 变体，例如：<code>setUTCHours()</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let today = new Date();</span><br><span class="line"></span><br><span class="line">today.setHours(0);</span><br><span class="line">alert(today); // 日期依然是今天，但是小时数被改为了 0</span><br><span class="line"></span><br><span class="line">today.setHours(0, 0, 0, 0);</span><br><span class="line">alert(today); // 日期依然是今天，时间为 00:00:00。</span><br></pre></td></tr></table></figure><h4 id="自动校准"><a href="#自动校准" class="headerlink" title="自动校准"></a>自动校准</h4><p>​    时间超过范围数值，date会自动校准</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?</span><br><span class="line">alert(date); // ……是 1st Feb 2013!</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let date = new Date(2016, 1, 28);</span><br><span class="line">date.setDate(date.getDate() + 2);</span><br><span class="line"></span><br><span class="line">alert( date ); // 1 Mar 2016</span><br></pre></td></tr></table></figure><p>PS:</p><p>二月的闰年，平年的情况不用考虑，date会自己处理</p><p>可以设置负值</p><h4 id="日期转换为数字，日期差值"><a href="#日期转换为数字，日期差值" class="headerlink" title="日期转换为数字，日期差值"></a>日期转换为数字，日期差值</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let date = new Date();</span><br><span class="line">alert(+date); // 以毫秒为单位的数值，与使用 date.getTime() 的结果相同</span><br></pre></td></tr></table></figure><p>解释：类似于字符串和数字的转换，结果为毫秒，同gettime（）</p><p>时间可以相减，相加,单位是毫秒</p><h4 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let start = Date.now(); // 从 1 Jan 1970 至今的时间戳</span><br><span class="line"></span><br><span class="line">// do the job</span><br><span class="line">for (let i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">  let doSomething = i * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let end = Date.now(); // 完成</span><br><span class="line"></span><br><span class="line">alert( `The loop took $&#123;end - start&#125; ms` ); // 相减的是时间戳，而不是日期</span><br></pre></td></tr></table></figure><p>解释：date.now（）类似于先创建date，然后gettime，只不过省略创建，相当于时间点之间的减法</p><h4 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h4><p>对函数反应时间进行测试，进而对整个测试体进行测试，从整体得出时间的度量</p><h4 id="Date-parse-str"><a href="#Date-parse-str" class="headerlink" title="Date.parse(str)"></a>Date.parse(str)</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ms = Date.parse(&#x27;2012-01-26T13:51:50.417-07:00&#x27;);</span><br><span class="line"></span><br><span class="line">alert(ms); // 1327611110417  (时间戳)</span><br></pre></td></tr></table></figure><p>解释：</p><p>str的格式：YYYY-MM-DDTHH:mm:ss.sssZ</p><ul><li><code>YYYY-MM-DD</code> —— 日期：年-月-日。</li><li>字符 <code>&quot;T&quot;</code> 是一个分隔符。</li><li><code>HH:mm:ss.sss</code> —— 时间：小时，分钟，秒，毫秒。</li><li>可选字符 <code>&#39;Z&#39;</code> 为 <code>+-hh:mm</code> 格式的时区。单个字符 <code>Z</code> 代表 UTC+0 时区。</li></ul><p>Date.parse（str）返回的是毫秒数，时间点。错误会返回NaN</p><h4 id="JSON方法-toJSON"><a href="#JSON方法-toJSON" class="headerlink" title="JSON方法 toJSON"></a>JSON方法 toJSON</h4><ul><li><code>JSON.stringify</code> 将对象转换为 JSON。</li><li><code>JSON.parse</code> 将 JSON 转换回对象。</li></ul><h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let student = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">  isAdmin: false,</span><br><span class="line">  courses: [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;js&#x27;],</span><br><span class="line">  spouse: null</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let json = JSON.stringify(student);</span><br><span class="line"></span><br><span class="line">alert(typeof json); // we&#x27;ve got a string!</span><br><span class="line"></span><br><span class="line">alert(json);</span><br><span class="line">/* JSON 编码的对象：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;age&quot;: 30,</span><br><span class="line">  &quot;isAdmin&quot;: false,</span><br><span class="line">  &quot;courses&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;],</span><br><span class="line">  &quot;spouse&quot;: null</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>PS：</p><ul><li>字符串使用双引号。JSON 中没有单引号或反引号。所以 <code>&#39;John&#39;</code> 被转换为 <code>&quot;John&quot;</code>。</li><li>对象属性名称也是双引号的。这是强制性的。所以 <code>age:30</code> 被转换成 <code>&quot;age&quot;:30</code>。</li></ul><p>以下属性值会被跳过：</p><ul><li>函数属性（方法）。</li><li>Symbol 类型的键和值。</li><li>存储 <code>undefined</code> 的属性。</li></ul><p>限制：</p><ul><li>不得有循环引用</li></ul><h5 id="排除和转换：replacer"><a href="#排除和转换：replacer" class="headerlink" title="排除和转换：replacer"></a>排除和转换：replacer</h5><p>语法：let json = JSON.stringify(value[, replacer, space])</p><p>解释：</p><p>value</p><p>要编码的值。</p><p>replacer</p><p>要编码的属性数组或映射函数 <code>function(key, value)</code>。</p><p>space</p><p>用于格式化的空格数量</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let room = &#123;</span><br><span class="line">  number: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let meetup = &#123;</span><br><span class="line">  title: &quot;Conference&quot;,</span><br><span class="line">  participants: [&#123;name: &quot;John&quot;&#125;, &#123;name: &quot;Alice&quot;&#125;],</span><br><span class="line">  place: room // meetup 引用了 room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; // room 引用了 meetup</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(meetup, [&#x27;title&#x27;, &#x27;participants&#x27;]) );</span><br><span class="line">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span><br></pre></td></tr></table></figure><p> 解释：因为在stringift参数中不含次级的name和number属性，因此不会显示 没有序列化</p><p>改进后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let room = &#123;</span><br><span class="line">  number: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let meetup = &#123;</span><br><span class="line">  title: &quot;Conference&quot;,</span><br><span class="line">  participants: [&#123;name: &quot;John&quot;&#125;, &#123;name: &quot;Alice&quot;&#125;],</span><br><span class="line">  place: room // meetup 引用了 room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; // room 引用了 meetup</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(meetup, [&#x27;title&#x27;, &#x27;participants&#x27;, &#x27;place&#x27;, &#x27;name&#x27;, &#x27;number&#x27;]) );</span><br><span class="line">/*</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;Conference&quot;,</span><br><span class="line">  &quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],</span><br><span class="line">  &quot;place&quot;:&#123;&quot;number&quot;:23&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h5 id="※示例"><a href="#※示例" class="headerlink" title="※示例"></a>※示例</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let room = &#123;</span><br><span class="line">  number: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let meetup = &#123;</span><br><span class="line">  title: &quot;Conference&quot;,</span><br><span class="line">  participants: [&#123;name: &quot;John&quot;&#125;, &#123;name: &quot;Alice&quot;&#125;],</span><br><span class="line">  place: room // meetup 引用了 room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; // room 引用了 meetup</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(meetup, function replacer(key, value) &#123;</span><br><span class="line">  alert(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">  return (key == &#x27;occupiedBy&#x27;) ? undefined : value;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">/* key:value pairs that come to replacer:</span><br><span class="line">:             [object Object]</span><br><span class="line">title:        Conference</span><br><span class="line">participants: [object Object],[object Object]</span><br><span class="line">0:            [object Object]</span><br><span class="line">name:         John</span><br><span class="line">1:            [object Object]</span><br><span class="line">name:         Alice</span><br><span class="line">place:        [object Object]</span><br><span class="line">number:       23</span><br><span class="line">occupiedBy: [object Object]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>解释：</p><p>请注意 <code>replacer</code> 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。<code>replacer</code> 中的 <code>this</code> 的值是包含当前属性的对象。</p><p>第一个调用很特别。它是使用特殊的“包装对象”制作的：<code>&#123;&quot;&quot;: meetup&#125;</code>。换句话说，第一个 <code>(key, value)</code> 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 <code>&quot;:[object Object]&quot;</code> 的原因。</p><p>（每一个对象名属性为空，0,1，….：值为：【object，object】）</p><h5 id="格式化：space"><a href="#格式化：space" class="headerlink" title="格式化：space"></a>格式化：space</h5><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">let room = &#123;</span><br><span class="line">  number: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let meetup = &#123;</span><br><span class="line">  title: &quot;Conference&quot;,</span><br><span class="line">  participants: [&#123;name: &quot;John&quot;&#125;, &#123;name: &quot;Alice&quot;&#125;],</span><br><span class="line">  place: room // meetup 引用了 room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; // room 引用了 meetup</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(meetup, [&#x27;title&#x27;, &#x27;participants&#x27;]) );</span><br><span class="line">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span><br><span class="line">这里我们可能过于严格了。属性列表应用于了整个对象结构。所以 participants 是空的，因为 name 不在列表中。</span><br><span class="line"></span><br><span class="line">让我们包含除了会导致循环引用的 room.occupiedBy 之外的所有属性：</span><br><span class="line"></span><br><span class="line">let room = &#123;</span><br><span class="line">  number: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let meetup = &#123;</span><br><span class="line">  title: &quot;Conference&quot;,</span><br><span class="line">  participants: [&#123;name: &quot;John&quot;&#125;, &#123;name: &quot;Alice&quot;&#125;],</span><br><span class="line">  place: room // meetup 引用了 room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; // room 引用了 meetup</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(meetup, [&#x27;title&#x27;, &#x27;participants&#x27;, &#x27;place&#x27;, &#x27;name&#x27;, &#x27;number&#x27;]) );</span><br><span class="line">/*</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;Conference&quot;,</span><br><span class="line">  &quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],</span><br><span class="line">  &quot;place&quot;:&#123;&quot;number&quot;:23&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">现在，除 occupiedBy 以外的所有内容都被序列化了。但是属性的列表太长了。</span><br><span class="line"></span><br><span class="line">幸运的是，我们可以使用一个函数代替数组作为 replacer。</span><br><span class="line"></span><br><span class="line">该函数会为每个 (key,value) 对调用并返回“已替换”的值，该值将替换原有的值。如果值被跳过了，则为 undefined。</span><br><span class="line"></span><br><span class="line">在我们的例子中，我们可以为 occupiedBy 以外的所有内容按原样返回 value。为了 occupiedBy，下面的代码返回 undefined：</span><br><span class="line"></span><br><span class="line">let room = &#123;</span><br><span class="line">  number: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let meetup = &#123;</span><br><span class="line">  title: &quot;Conference&quot;,</span><br><span class="line">  participants: [&#123;name: &quot;John&quot;&#125;, &#123;name: &quot;Alice&quot;&#125;],</span><br><span class="line">  place: room // meetup 引用了 room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; // room 引用了 meetup</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(meetup, function replacer(key, value) &#123;</span><br><span class="line">  alert(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">  return (key == &#x27;occupiedBy&#x27;) ? undefined : value;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">/* key:value pairs that come to replacer:</span><br><span class="line">:             [object Object]</span><br><span class="line">title:        Conference</span><br><span class="line">participants: [object Object],[object Object]</span><br><span class="line">0:            [object Object]</span><br><span class="line">name:         John</span><br><span class="line">1:            [object Object]</span><br><span class="line">name:         Alice</span><br><span class="line">place:        [object Object]</span><br><span class="line">number:       23</span><br><span class="line">occupiedBy: [object Object]</span><br><span class="line">*/</span><br><span class="line">请注意 replacer 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。replacer 中的 this 的值是包含当前属性的对象。</span><br><span class="line"></span><br><span class="line">第一个调用很特别。它是使用特殊的“包装对象”制作的：&#123;&quot;&quot;: meetup&#125;。换句话说，第一个 (key, value) 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 &quot;:[object Object]&quot; 的原因。</span><br><span class="line"></span><br><span class="line">这个理念是为了给 replacer 提供尽可能多的功能：如果有必要，它有机会分析并替换/跳过整个对象。</span><br><span class="line"></span><br><span class="line">格式化：space</span><br><span class="line">JSON.stringify(value, replacer, spaces) 的第三个参数是用于优化格式的空格数量。</span><br><span class="line"></span><br><span class="line">以前，所有字符串化的对象都没有缩进和额外的空格。如果我们想通过网络发送一个对象，那就没什么问题。space 参数专门用于调整出更美观的输出。</span><br><span class="line"></span><br><span class="line">这里的 space = 2 告诉 JavaScript 在多行中显示嵌套的对象，对象内部缩进 2 个空格：</span><br><span class="line"></span><br><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  age: 25,</span><br><span class="line">  roles: &#123;</span><br><span class="line">    isAdmin: false,</span><br><span class="line">    isEditor: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(JSON.stringify(user, null, 2));</span><br><span class="line">/* 两个空格的缩进：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;age&quot;: 25,</span><br><span class="line">  &quot;roles&quot;: &#123;</span><br><span class="line">    &quot;isAdmin&quot;: false,</span><br><span class="line">    &quot;isEditor&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* 对于 JSON.stringify(user, null, 4) 的结果会有更多缩进：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">    &quot;age&quot;: 25,</span><br><span class="line">    &quot;roles&quot;: &#123;</span><br><span class="line">        &quot;isAdmin&quot;: false,</span><br><span class="line">        &quot;isEditor&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>解释：</p><p>告诉JS  对象缩进</p><p>第三个参数也可以是字符串。在这种情况下，字符串用于缩进，而不是空格的数量。</p><p><code>spaces</code> 参数仅用于日志记录和美化输出。</p><h5 id="自定义“toJSON”"><a href="#自定义“toJSON”" class="headerlink" title="自定义“toJSON”"></a>自定义“toJSON”</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let room = &#123;</span><br><span class="line">  number: 23,</span><br><span class="line">  toJSON() &#123;</span><br><span class="line">    return this.number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let meetup = &#123;</span><br><span class="line">  title: &quot;Conference&quot;,</span><br><span class="line">  room</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(room) ); // 23</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(meetup) );</span><br><span class="line">/*</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;:&quot;Conference&quot;,</span><br><span class="line">    &quot;room&quot;: 23</span><br><span class="line">  &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h5><p>解码 JSON 字符串</p><p>语法：let value = JSON.parse(str, [reviver]);</p><p>解释：</p><p>str</p><p>要解析的 JSON 字符串。</p><p>reviver</p><p>可选的函数 function(key,value)，该函数将为每个 <code>(key, value)</code> 对调用，并可以对值进行转换。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ 字符串化数组</span><br><span class="line">let numbers = &quot;[0, 1, 2, 3]&quot;;</span><br><span class="line"></span><br><span class="line">numbers = JSON.parse(numbers);</span><br><span class="line"></span><br><span class="line">alert( numbers[1] ); // 1</span><br></pre></td></tr></table></figure><p>嵌套：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let userData = &#x27;&#123; &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] &#125;&#x27;;</span><br><span class="line"></span><br><span class="line">let user = JSON.parse(userData);</span><br><span class="line"></span><br><span class="line">alert( user.friends[1] ); // 1</span><br></pre></td></tr></table></figure><p>PS：在转换是要符合JSON的规则</p><p>错误示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let json = `&#123;</span><br><span class="line">  name: &quot;John&quot;,                     // 错误：属性名没有双引号</span><br><span class="line">  &quot;surname&quot;: &#x27;Smith&#x27;,               // 错误：值使用的是单引号（必须使用双引号）</span><br><span class="line">  &#x27;isAdmin&#x27;: false                  // 错误：键使用的是单引号（必须使用双引号）</span><br><span class="line">  &quot;birthday&quot;: new Date(2000, 2, 3), // 错误：不允许使用 &quot;new&quot;，只能是裸值</span><br><span class="line">  &quot;friends&quot;: [0,1,2,3]              // 这个没问题</span><br><span class="line">&#125;`;</span><br></pre></td></tr></table></figure><h5 id="reviver"><a href="#reviver" class="headerlink" title="reviver"></a>reviver</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let schedule = `&#123;</span><br><span class="line">  &quot;meetups&quot;: [</span><br><span class="line">    &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;&#125;,</span><br><span class="line">    &#123;&quot;title&quot;:&quot;Birthday&quot;,&quot;date&quot;:&quot;2017-04-18T12:00:00.000Z&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;`;</span><br><span class="line"></span><br><span class="line">schedule = JSON.parse(schedule, function(key, value) &#123;</span><br><span class="line">  if (key == &#x27;date&#x27;) return new Date(value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert( schedule.meetups[1].date.getDate() ); // 正常运行了！</span><br></pre></td></tr></table></figure><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><hr><h3 id="Rest参数和Spread语法"><a href="#Rest参数和Spread语法" class="headerlink" title="Rest参数和Spread语法"></a>Rest参数和Spread语法</h3><h4 id="Rest参数-…"><a href="#Rest参数-…" class="headerlink" title="Rest参数 …"></a>Rest参数 …</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function showName(firstName, lastName, ...titles) &#123;</span><br><span class="line">  alert( firstName + &#x27; &#x27; + lastName ); // Julius Caesar</span><br><span class="line"></span><br><span class="line">  // 剩余的参数被放入 titles 数组中</span><br><span class="line">  // i.e. titles = [&quot;Consul&quot;, &quot;Imperator&quot;]</span><br><span class="line">  alert( titles[0] ); // Consul</span><br><span class="line">  alert( titles[1] ); // Imperator</span><br><span class="line">  alert( titles.length ); // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showName(&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;Imperator&quot;);</span><br></pre></td></tr></table></figure><p>解释：类似于解构里面，剩余数据用“…name”形式新建数组存储</p><p>PS：…name 必须放在参数最后一个</p><h4 id="“arguments”变量"><a href="#“arguments”变量" class="headerlink" title="“arguments”变量"></a>“arguments”变量</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function showName() &#123;</span><br><span class="line">  alert( arguments.length );</span><br><span class="line">  alert( arguments[0] );</span><br><span class="line">  alert( arguments[1] );</span><br><span class="line"></span><br><span class="line">  // 它是可遍历的</span><br><span class="line">  // for(let arg of arguments) alert(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 依次显示：2，Julius，Caesar</span><br><span class="line">showName(&quot;Julius&quot;, &quot;Caesar&quot;);</span><br><span class="line"></span><br><span class="line">// 依次显示：1，Ilya，undefined（没有第二个参数）</span><br><span class="line">showName(&quot;Ilya&quot;);</span><br></pre></td></tr></table></figure><p>解释：以类数组所在位置作为键</p><p>PS:箭头函数没有arguments this</p><h4 id="Spread-语法"><a href="#Spread-语法" class="headerlink" title="Spread 语法"></a>Spread 语法</h4><p>​    从数组中获取参数，类似于rest语法</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [3, 5, 1];</span><br><span class="line"></span><br><span class="line">alert( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）</span><br></pre></td></tr></table></figure><p>可迭代多个，可与常规值结合，可合并数组，可应用与数组</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">et arr1 = [1, -2, 3, 4];</span><br><span class="line">let arr2 = [8, 3, -8, 1];</span><br><span class="line"></span><br><span class="line">alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">alert( [...str] ); // H,e,l,l,o</span><br></pre></td></tr></table></figure><p>PS：spread与array.from区别;</p><ul><li><code>Array.from</code> 适用于类数组对象也适用于可迭代对象。</li><li>Spread 语法只适用于可迭代对象。</li></ul><p>因此，对于将一些“东西”转换为数组的任务，<code>Array.from</code> 往往更通用。</p><h4 id="复制array-object"><a href="#复制array-object" class="headerlink" title="复制array/object"></a>复制array/object</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let arrCopy = [...arr]; // 将数组 spread 到参数列表中</span><br><span class="line">                        // 然后将结果放到一个新数组</span><br><span class="line"></span><br><span class="line">// 两个数组中的内容相同吗？</span><br><span class="line">alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true</span><br><span class="line"></span><br><span class="line">// 两个数组相等吗？</span><br><span class="line">alert(arr === arrCopy); // false（它们的引用是不同的）</span><br><span class="line"></span><br><span class="line">// 修改我们初始的数组不会修改副本：</span><br><span class="line">arr.push(4);</span><br><span class="line">alert(arr); // 1, 2, 3, 4</span><br><span class="line">alert(arrCopy); // 1, 2, 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">let objCopy = &#123; ...obj &#125;; // 将对象 spread 到参数列表中</span><br><span class="line">                          // 然后将结果返回到一个新对象</span><br><span class="line"></span><br><span class="line">// 两个对象中的内容相同吗？</span><br><span class="line">alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true</span><br><span class="line"></span><br><span class="line">// 两个对象相等吗？</span><br><span class="line">alert(obj === objCopy); // false (not same reference)</span><br><span class="line"></span><br><span class="line">// 修改我们初始的对象不会修改副本：</span><br><span class="line">obj.d = 4;</span><br><span class="line">alert(JSON.stringify(obj)); // &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4&#125;</span><br><span class="line">alert(JSON.stringify(objCopy)); // &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;</span><br></pre></td></tr></table></figure><p>PS：浅层复制可用，所以在情况允许下（object.assign（【】，arr），object.assign（【】，obj）），建议使用此方法。</p><p><img src="https://uploads.disquscdn.com/images/d375a8d841860f48b037cc9f9044e338b4a2d07b33816a4c3fc01fc733662d06.png" alt="img"></p><h3 id="老旧的“var”"><a href="#老旧的“var”" class="headerlink" title="老旧的“var”"></a>老旧的“var”</h3><hr><h4 id="var-没有块级作用域"><a href="#var-没有块级作用域" class="headerlink" title="var 没有块级作用域"></a>var 没有块级作用域</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  var test = true; // 使用 &quot;var&quot; 而不是 &quot;let&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(test); // true，变量在 if 结束后仍存在</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var phrase = &quot;Hello&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(phrase); // 能正常工作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br><span class="line">alert(phrase); // ReferenceError: phrase is not defined</span><br></pre></td></tr></table></figure><p>解释：var定义的变量，在全局中则为全局变量，在函数中则为函数变量，没有块级变量的情况</p><h4 id="var-允许重新声明"><a href="#var-允许重新声明" class="headerlink" title="var 允许重新声明"></a>var 允许重新声明</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var user = &quot;Pete&quot;;</span><br><span class="line"></span><br><span class="line">var user = &quot;John&quot;; // 这个 &quot;var&quot; 无效（因为变量已经声明过了）</span><br><span class="line">// ……不会触发错误</span><br><span class="line"></span><br><span class="line">alert(user); // John</span><br></pre></td></tr></table></figure><p>解释：let重复定义变量会报错，var则会以最后一次为准</p><h4 id="var-声明的变量-可以在声明前使用"><a href="#var-声明的变量-可以在声明前使用" class="headerlink" title="var 声明的变量 可以在声明前使用"></a>var 声明的变量 可以在声明前使用</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  phrase = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">  alert(phrase);</span><br><span class="line"></span><br><span class="line">  var phrase;</span><br><span class="line">&#125;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure><p>解释： var声明会被提升，赋值不会被提升，因此可以在声明前使用</p><h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>一种模仿块级作用域的方法，被称为“立即调用函数表达式”</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line"></span><br><span class="line">  var message = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">  alert(message); // Hello</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>解释：用圆括号将函数表达式包起来，表明为立即调用函数</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><hr><p>​    内建全局变量，在浏览器中为 “window”，在node.js为global，最近globalthis作为全局变量标准名加入js</p><p>var 声明会变成全局变量的属性：</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var gVar = 5;</span><br><span class="line"></span><br><span class="line">alert(window.gVar); // 5（成为了全局对象的属性）</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将当前用户信息全局化，以允许所有脚本访问它</span><br><span class="line">window.currentUser = &#123;</span><br><span class="line">  name: &quot;John&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 代码中的另一个位置</span><br><span class="line">alert(currentUser.name);  // John</span><br><span class="line"></span><br><span class="line">// 或者，如果我们有一个名为 &quot;currentUser&quot; 的局部变量</span><br><span class="line">// 从 window 显式地获取它（这是安全的！）</span><br><span class="line">alert(window.currentUser.name); // John</span><br></pre></td></tr></table></figure><h4 id="使用polyfills"><a href="#使用polyfills" class="headerlink" title="使用polyfills"></a>使用polyfills</h4><p>​    测试是否存在内建promise对象</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!window.Promise) &#123;</span><br><span class="line">  alert(&quot;Your browser is really old!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数对象-NFE"><a href="#函数对象-NFE" class="headerlink" title="函数对象 NFE"></a>函数对象 NFE</h3><hr><p>​    函数可视为行为对象，可以应用对象方法</p><h4 id="属性“name”"><a href="#属性“name”" class="headerlink" title="属性“name”"></a>属性“name”</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(sayHi.name); // sayHi</span><br></pre></td></tr></table></figure><p>解释：显式的name直接输出，没有直接说明则会通过上下文进行推测，无法推测时会返回 空。</p><h4 id="属性“length”"><a href="#属性“length”" class="headerlink" title="属性“length”"></a>属性“length”</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1(a) &#123;&#125;</span><br><span class="line">function f2(a, b) &#123;&#125;</span><br><span class="line">function many(a, b, ...more) &#123;&#125;</span><br><span class="line"></span><br><span class="line">alert(f1.length); // 1</span><br><span class="line">alert(f2.length); // 2</span><br><span class="line">alert(many.length); // 2</span><br></pre></td></tr></table></figure><p>解释：…name 不计入参数</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function ask(question, ...handlers) &#123;</span><br><span class="line">  let isYes = confirm(question);</span><br><span class="line"></span><br><span class="line">  for(let handler of handlers) &#123;</span><br><span class="line">    if (handler.length == 0) &#123;</span><br><span class="line">      if (isYes) handler();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      handler(isYes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对于肯定的回答，两个 handler 都会被调用</span><br><span class="line">// 对于否定的回答，只有第二个 handler 被调用</span><br><span class="line">ask(&quot;Question?&quot;, () =&gt; alert(&#x27;You said yes&#x27;), result =&gt; alert(result));</span><br></pre></td></tr></table></figure><h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  alert(&quot;Hi&quot;);</span><br><span class="line"></span><br><span class="line">  // 计算调用次数</span><br><span class="line">  sayHi.counter++;</span><br><span class="line">&#125;</span><br><span class="line">sayHi.counter = 0; // 初始值</span><br><span class="line"></span><br><span class="line">sayHi(); // Hi</span><br><span class="line">sayHi(); // Hi</span><br><span class="line"></span><br><span class="line">alert( `Called $&#123;sayHi.counter&#125; times` ); // Called 2 times</span><br></pre></td></tr></table></figure><p>解释：类似于对象的属性添加</p><p>eg：</p><p>封装函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function makeCounter() &#123;</span><br><span class="line">  // 不需要这个了</span><br><span class="line">  // let count = 0</span><br><span class="line"></span><br><span class="line">  function counter() &#123;</span><br><span class="line">    return counter.count++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  counter.count = 0;</span><br><span class="line"></span><br><span class="line">  return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let counter = makeCounter();</span><br><span class="line">alert( counter() ); // 0</span><br><span class="line">alert( counter() ); // 1</span><br></pre></td></tr></table></figure><h4 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let sayHi = function func(who) &#123;</span><br><span class="line">  if (who) &#123;</span><br><span class="line">    alert(`Hello, $&#123;who&#125;`);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    func(&quot;Guest&quot;); // 使用 func 再次调用函数自身</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHi(); // Hello, Guest</span><br><span class="line"></span><br><span class="line">// 但这不工作：</span><br><span class="line">func(); // Error, func is not defined（在函数外不可见）</span><br></pre></td></tr></table></figure><p>PS：</p><ol><li>它允许函数在内部引用自己。</li><li>它在函数外是不可见的。</li></ol><p>解释：为了防止错误，可视为默认值设置，函数内部自己调用自己</p><h3 id="“New-Function”语法"><a href="#“New-Function”语法" class="headerlink" title="“New Function”语法"></a>“New Function”语法</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let func = new Function ([arg1, arg2, ...argN], functionBody);</span><br></pre></td></tr></table></figure><p>解释：通过参数以及给定的方法functionbody创建</p><p>不同声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a + b&#x27;); // 基础语法</span><br><span class="line">new Function(&#x27;a,b&#x27;, &#x27;return a + b&#x27;); // 逗号分隔</span><br><span class="line">new Function(&#x27;a , b&#x27;, &#x27;return a + b&#x27;); // 逗号和空格分隔</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sayHi = new Function(&#x27;alert(&quot;Hello&quot;)&#x27;);</span><br><span class="line"></span><br><span class="line">sayHi(); // Hello</span><br></pre></td></tr></table></figure><p>解释：直接通过字符串，变为函数</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getFunc() &#123;</span><br><span class="line">  let value = &quot;test&quot;;</span><br><span class="line"></span><br><span class="line">  let func = new Function(&#x27;alert(value)&#x27;);</span><br><span class="line"></span><br><span class="line">  return func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFunc()(); // error: value is not defined</span><br></pre></td></tr></table></figure><p>解释：new function创建的函数，访问全局变量，不会从局部变量开始，因此会出现错误</p><h3 id="调度：setTimeout和setInterval"><a href="#调度：setTimeout和setInterval" class="headerlink" title="调度：setTimeout和setInterval"></a>调度：setTimeout和setInterval</h3><p>​    延迟调用或时间判断后调用</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func|code</span><br></pre></td></tr></table></figure><p>想要执行的函数或代码字符串。 一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delay</span><br></pre></td></tr></table></figure><p>执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；</p><p><code>arg1</code>，<code>arg2</code>…</p><p>要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHi(phrase, who) &#123;</span><br><span class="line">  alert( phrase + &#x27;, &#x27; + who );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(sayHi, 1000, &quot;Hello&quot;, &quot;John&quot;); // Hello, John</span><br></pre></td></tr></table></figure><p>PS：</p><ul><li>可以传入字符串或者箭头函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(&quot;alert(&#x27;Hello&#x27;)&quot;, 1000);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; alert(&#x27;Hello&#x27;), 1000);</span><br></pre></td></tr></table></figure><ul><li>传入的是被执行函数名，即不加括号不执行</li></ul><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 错的！</span><br><span class="line">setTimeout(sayHi(), 1000);</span><br></pre></td></tr></table></figure><h4 id="clearTimeout-取消调度"><a href="#clearTimeout-取消调度" class="headerlink" title="clearTimeout 取消调度"></a>clearTimeout 取消调度</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let timerId = setTimeout(...);</span><br><span class="line">clearTimeout(timerId);</span><br></pre></td></tr></table></figure><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)</span><br></pre></td></tr></table></figure><p>解释：类似于setTimeout，但是setInterval会周期性执行</p><h4 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval"></a>clearInterval</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let timerId = setInterval(...);</span><br><span class="line">clearInterval(timerId);</span><br></pre></td></tr></table></figure><h4 id="嵌套setTimeout"><a href="#嵌套setTimeout" class="headerlink" title="嵌套setTimeout"></a>嵌套setTimeout</h4><p>若不用setInterval实现周期调用，这可以使用setTimeout的嵌套</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** instead of:</span><br><span class="line">let timerId = setInterval(() =&gt; alert(&#x27;tick&#x27;), 2000);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">let timerId = setTimeout(function tick() &#123;</span><br><span class="line">  alert(&#x27;tick&#x27;);</span><br><span class="line">  timerId = setTimeout(tick, 2000); // (*)</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure><h4 id="零延时的setTimeout"><a href="#零延时的setTimeout" class="headerlink" title="零延时的setTimeout"></a>零延时的setTimeout</h4><p>​    <code>setTimeout(func, 0)</code>，或者仅仅是 <code>setTimeout(func)</code>。</p><p>这样调度可以让 <code>func</code> 尽快执行。但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。也就是说，该函数被调度在当前脚本执行完成“之后”立即执行。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; alert(&quot;World&quot;));</span><br><span class="line"></span><br><span class="line">alert(&quot;Hello&quot;);</span><br></pre></td></tr></table></figure><p>解释：整个输出会hello 再 world，因为setTimeout零延迟要在整个脚本执行完，即代码运行完后执行</p><h3 id="装饰器模式和转发-call-apply"><a href="#装饰器模式和转发-call-apply" class="headerlink" title="装饰器模式和转发  call/apply"></a>装饰器模式和转发  call/apply</h3><hr><h4 id="透明缓存-装饰器"><a href="#透明缓存-装饰器" class="headerlink" title="透明缓存 装饰器"></a>透明缓存 装饰器</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function slow(x) &#123;</span><br><span class="line">  // 这里可能会有重负载的 CPU 密集型工作</span><br><span class="line">  alert(`Called with $&#123;x&#125;`);</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cachingDecorator(func) &#123;</span><br><span class="line">  let cache = new Map();</span><br><span class="line"></span><br><span class="line">  return function(x) &#123;</span><br><span class="line">    if (cache.has(x)) &#123;    // 如果缓存中有对应的结果</span><br><span class="line">      return cache.get(x); // 从缓存中读取结果</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let result = func(x);  // 否则就调用 func</span><br><span class="line"></span><br><span class="line">    cache.set(x, result);  // 然后将结果缓存（记住）下来</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slow = cachingDecorator(slow);</span><br><span class="line"></span><br><span class="line">alert( slow(1) ); // slow(1) 被缓存下来了，并返回结果</span><br><span class="line">alert( &quot;Again: &quot; + slow(1) ); // 返回缓存中的 slow(1) 的结果</span><br><span class="line"></span><br><span class="line">alert( slow(2) ); // slow(2) 被缓存下来了，并返回结果</span><br><span class="line">alert( &quot;Again: &quot; + slow(2) ); // 返回缓存中的 slow(2) 的结果</span><br></pre></td></tr></table></figure><p>优势：</p><ul><li><code>cachingDecorator</code> 是可重用的。我们可以将它应用于另一个函数。</li><li>缓存逻辑是独立的，它没有增加 <code>slow</code> 本身的复杂性（如果有的话）。</li><li>如果需要，我们可以组合多个装饰器（其他装饰器将遵循同样的逻辑）。</li></ul><p>PS：不适用于对象</p><h4 id="func-call-设定上下文"><a href="#func-call-设定上下文" class="headerlink" title="func.call 设定上下文"></a>func.call 设定上下文</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(context, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#123; name: &quot;John&quot; &#125;;</span><br><span class="line">let admin = &#123; name: &quot;Admin&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// 使用 call 将不同的对象传递为 &quot;this&quot;</span><br><span class="line">sayHi.call( user ); // John</span><br><span class="line">sayHi.call( admin ); // Admin</span><br></pre></td></tr></table></figure><h4 id="※传递多个参数"><a href="#※传递多个参数" class="headerlink" title="※传递多个参数"></a>※传递多个参数</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let worker = &#123;</span><br><span class="line">  slow(min, max) &#123;</span><br><span class="line">    alert(`Called with $&#123;min&#125;,$&#123;max&#125;`);</span><br><span class="line">    return min + max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function cachingDecorator(func, hash) &#123;</span><br><span class="line">  let cache = new Map();</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let key = hash(arguments); // (*)</span><br><span class="line">    if (cache.has(key)) &#123;</span><br><span class="line">      return cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let result = func.call(this, ...arguments); // (**)</span><br><span class="line"></span><br><span class="line">    cache.set(key, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hash(args) &#123;</span><br><span class="line">  return args[0] + &#x27;,&#x27; + args[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow, hash);</span><br><span class="line"></span><br><span class="line">alert( worker.slow(3, 5) ); // works</span><br><span class="line">alert( &quot;Again &quot; + worker.slow(3, 5) ); // same (cached)</span><br></pre></td></tr></table></figure><h4 id="func-apply"><a href="#func-apply" class="headerlink" title="func.apply"></a>func.apply</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(context, args)</span><br></pre></td></tr></table></figure><p>解释：类似于</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func.call(context, ...args);</span><br><span class="line">func.apply(context, args);</span><br></pre></td></tr></table></figure><h4 id="方法借用-借用一种方法"><a href="#方法借用-借用一种方法" class="headerlink" title="方法借用-借用一种方法"></a>方法借用-借用一种方法</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function hash() &#123;</span><br><span class="line">  alert( arguments.join() ); // Error: arguments.join is not a function</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash(1, 2);</span><br></pre></td></tr></table></figure><p>直接使用join方法显示错误</p><p>修改办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function hash() &#123;</span><br><span class="line">  alert( [].join.call(arguments) ); // 1,2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash(1, 2);</span><br></pre></td></tr></table></figure><p>解释：先在[].join形式调用，在用join.call进行指定</p><h4 id="装饰器和函数属性"><a href="#装饰器和函数属性" class="headerlink" title="装饰器和函数属性"></a>装饰器和函数属性</h4><p>​    装饰后的函数，不具备原来的某些属性</p><h3 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h3><hr><p>​    为解决this与函数分离，产生this未指向</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  firstName: &quot;John&quot;,</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(`Hello, $&#123;this.firstName&#125;!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(user.sayHi, 1000); // Hello, undefined!</span><br></pre></td></tr></table></figure><h4 id="解决方案1：包装器"><a href="#解决方案1：包装器" class="headerlink" title="解决方案1：包装器"></a>解决方案1：包装器</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  firstName: &quot;John&quot;,</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(`Hello, $&#123;this.firstName&#125;!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  user.sayHi(); // Hello, John!</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; user.sayHi(), 1000); // Hello, John!</span><br></pre></td></tr></table></figure><h4 id="解决方案2：bind"><a href="#解决方案2：bind" class="headerlink" title="解决方案2：bind"></a>解决方案2：bind</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let boundFunc = func.bind(context);</span><br></pre></td></tr></table></figure><p>解释：类似于call，直接给函数绑定this</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  firstName: &quot;John&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">  alert(this.firstName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let funcUser = func.bind(user);</span><br><span class="line">funcUser(); // John</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  firstName: &quot;John&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function func(phrase) &#123;</span><br><span class="line">  alert(phrase + &#x27;, &#x27; + this.firstName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将 this 绑定到 user</span><br><span class="line">let funcUser = func.bind(user);</span><br><span class="line"></span><br><span class="line">funcUser(&quot;Hello&quot;); // Hello, John（参数 &quot;Hello&quot; 被传递，并且 this=user）</span><br></pre></td></tr></table></figure><h4 id="多对象方法传递-bindAll"><a href="#多对象方法传递-bindAll" class="headerlink" title="多对象方法传递  bindAll"></a>多对象方法传递  bindAll</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let key in user) &#123;</span><br><span class="line">  if (typeof user[key] == &#x27;function&#x27;) &#123;</span><br><span class="line">    user[key] = user[key].bind(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let bound = func.bind(context, [arg1], [arg2], ...);</span><br></pre></td></tr></table></figure><p>解释：不仅绑定了对象context，并且绑定了参数 arg</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function mul(a, b) &#123;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let double = mul.bind(null, 2);</span><br><span class="line"></span><br><span class="line">alert( double(3) ); // = mul(2, 3) = 6</span><br><span class="line">alert( double(4) ); // = mul(2, 4) = 8</span><br><span class="line">alert( double(5) ); // = mul(2, 5) = 10</span><br></pre></td></tr></table></figure><h4 id="在没有上下文情况下的-partial"><a href="#在没有上下文情况下的-partial" class="headerlink" title="在没有上下文情况下的 partial"></a>在没有上下文情况下的 partial</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function partial(func, ...argsBound) &#123;</span><br><span class="line">  return function(...args) &#123; // (*)</span><br><span class="line">    return func.call(this, ...argsBound, ...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用法：</span><br><span class="line">let user = &#123;</span><br><span class="line">  firstName: &quot;John&quot;,</span><br><span class="line">  say(time, phrase) &#123;</span><br><span class="line">    alert(`[$&#123;time&#125;] $&#123;this.firstName&#125;: $&#123;phrase&#125;!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 添加一个带有绑定时间的 partial 方法</span><br><span class="line">user.sayNow = partial(user.say, new Date().getHours() + &#x27;:&#x27; + new Date().getMinutes());</span><br><span class="line"></span><br><span class="line">user.sayNow(&quot;Hello&quot;);</span><br><span class="line">// 类似于这样的一些内容：</span><br><span class="line">// [10:00] John: Hello!</span><br></pre></td></tr></table></figure><p>PS:不能被重绑定</p><h3 id="深入理解箭头函数"><a href="#深入理解箭头函数" class="headerlink" title="深入理解箭头函数"></a>深入理解箭头函数</h3><ul><li>箭头函数没有this</li><li>箭头函数没有new操作</li><li>箭头函数没有arguments（类数组）</li></ul><h2 id="对象属性配置"><a href="#对象属性配置" class="headerlink" title="对象属性配置"></a>对象属性配置</h2><ul><li><strong><code>writable</code></strong> — 如果为 <code>true</code>，则值可以被修改，否则它是只可读的。</li><li><strong><code>enumerable</code></strong> — 如果为 <code>true</code>，则会被在循环中列出，否则不会被列出。</li><li><strong><code>configurable</code></strong> — 如果为 <code>true</code>，则此属性可以被删除，这些特性也可以被修改，否则不可以。</li></ul><h4 id="属性标志"><a href="#属性标志" class="headerlink" title="属性标志"></a>属性标志</h4><h5 id="获取有关属性的完整信息"><a href="#获取有关属性的完整信息" class="headerlink" title="获取有关属性的完整信息"></a>获取有关属性的完整信息</h5><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj</span><br></pre></td></tr></table></figure><p>需要从中获取信息的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propertyName</span><br></pre></td></tr></table></figure><p>属性的名称。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;John&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let descriptor = Object.getOwnPropertyDescriptor(user, &#x27;name&#x27;);</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(descriptor, null, 2 ) );</span><br><span class="line">/* 属性描述符：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;writable&quot;: true,</span><br><span class="line">  &quot;enumerable&quot;: true,</span><br><span class="line">  &quot;configurable&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h5 id="修改标志"><a href="#修改标志" class="headerlink" title="修改标志"></a>修改标志</h5><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, propertyName, descriptor)</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj`，`propertyName</span><br></pre></td></tr></table></figure><p>要应用描述符的对象及其属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptor</span><br></pre></td></tr></table></figure><p>要应用的属性描述符对象。</p><p>对某一标志进行修改，则以键值对形式对descriptor进行修改</p><p>如果该属性存在，defineProperty 会更新其标志。否则，它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 false。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(user, &quot;name&quot;, &#123;</span><br><span class="line">  value: &quot;John&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let descriptor = Object.getOwnPropertyDescriptor(user, &#x27;name&#x27;);</span><br><span class="line"></span><br><span class="line">alert( JSON.stringify(descriptor, null, 2 ) );</span><br><span class="line">/*</span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;writable&quot;: false,</span><br><span class="line">  &quot;enumerable&quot;: false,</span><br><span class="line">  &quot;configurable&quot;: false</span><br><span class="line">&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h5><p>​    不可更改属性，标志，但可以更改属性值</p><h5 id="同时设置多个标志"><a href="#同时设置多个标志" class="headerlink" title="同时设置多个标志"></a>同时设置多个标志</h5><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(obj,... )</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(obj, &#123;</span><br><span class="line">  prop1: descriptor1,</span><br><span class="line">  prop2: descriptor2</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter setter"></a>getter setter</h3><p>​    get 创建，set 创建值 修改值</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  surname: &quot;Smith&quot;,</span><br><span class="line"></span><br><span class="line">  get fullName() &#123;</span><br><span class="line">    return `$&#123;this.name&#125; $&#123;this.surname&#125;`;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set fullName(value) &#123;</span><br><span class="line">    [this.name, this.surname] = value.split(&quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// set fullName 将以给定值执行</span><br><span class="line">user.fullName = &quot;Alice Cooper&quot;;</span><br><span class="line"></span><br><span class="line">alert(user.name); // Alice</span><br><span class="line">alert(user.surname); // Cooper</span><br></pre></td></tr></table></figure><p>解释：将set进行结构分别赋值，起到修改的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  surname: &quot;Smith&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(user, &#x27;fullName&#x27;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return `$&#123;this.name&#125; $&#123;this.surname&#125;`;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set(value) &#123;</span><br><span class="line">    [this.name, this.surname] = value.split(&quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(user.fullName); // John Smith</span><br><span class="line"></span><br><span class="line">for(let key in user) alert(key); // name, surname</span><br></pre></td></tr></table></figure><p>解释：访问器和数据属性不能同时存在，遍历时访问器不被输出</p><h4 id="更优的getter和setter"><a href="#更优的getter和setter" class="headerlink" title="更优的getter和setter"></a>更优的getter和setter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this._name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    if (value.length &lt; 4) &#123;</span><br><span class="line">      alert(&quot;Name is too short, need at least 4 characters&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    this._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.name = &quot;Pete&quot;;</span><br><span class="line">alert(user.name); // Pete</span><br><span class="line"></span><br><span class="line">user.name = &quot;&quot;; // Name 太短了……</span><br></pre></td></tr></table></figure><p>PS：__name，内部单独属性，约定:_内部属性，不应该从对象外部进行访问</p><h4 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function User(name, birthday) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.birthday = birthday;</span><br><span class="line"></span><br><span class="line">  // 年龄是根据当前日期和生日计算得出的</span><br><span class="line">  Object.defineProperty(this, &quot;age&quot;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      let todayYear = new Date().getFullYear();</span><br><span class="line">      return todayYear - this.birthday.getFullYear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let john = new User(&quot;John&quot;, new Date(1992, 6, 1));</span><br><span class="line"></span><br><span class="line">alert( john.birthday ); // birthday 是可访问的</span><br></pre></td></tr></table></figure><p>解释：用defineProperty创建age，用get进行赋值</p><h2 id="原型-继承"><a href="#原型-继承" class="headerlink" title="原型 继承"></a>原型 继承</h2><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>​    prototype要么为null，要么为另一个对象(理解为父级？)继承对象</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object._proto_=object</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let animal = &#123;</span><br><span class="line">  eats: true,</span><br><span class="line">  walk() &#123;</span><br><span class="line">    alert(&quot;Animal walk&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let rabbit = &#123;</span><br><span class="line">  jumps: true,</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let longEar = &#123;</span><br><span class="line">  earLength: 10,</span><br><span class="line">  __proto__: rabbit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// walk 是通过原型链获得的</span><br><span class="line">longEar.walk(); // Animal walk</span><br><span class="line">alert(longEar.jumps); // true（从 rabbit）</span><br></pre></td></tr></table></figure><p>PS:</p><ul><li>自下而上的寻找</li><li>可以原链寻找，但不能为闭环</li><li>原型仅用于读取，不用于修改和写入</li></ul><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  surname: &quot;Smith&quot;,</span><br><span class="line"></span><br><span class="line">  set fullName(value) &#123;</span><br><span class="line">    [this.name, this.surname] = value.split(&quot; &quot;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  get fullName() &#123;</span><br><span class="line">    return `$&#123;this.name&#125; $&#123;this.surname&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let admin = &#123;</span><br><span class="line">  __proto__: user,</span><br><span class="line">  isAdmin: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); // John Smith (*)</span><br><span class="line"></span><br><span class="line">// setter triggers!</span><br><span class="line">admin.fullName = &quot;Alice Cooper&quot;; // (**)</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); // Alice Cooper，admin 的内容被修改了</span><br><span class="line">alert(user.fullName);  // John Smith，user 的内容被保护了</span><br></pre></td></tr></table></figure><h4 id="this属性"><a href="#this属性" class="headerlink" title="this属性"></a>this属性</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// animal 有一些方法</span><br><span class="line">let animal = &#123;</span><br><span class="line">  walk() &#123;</span><br><span class="line">    if (!this.isSleeping) &#123;</span><br><span class="line">      alert(`I walk`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  sleep() &#123;</span><br><span class="line">    this.isSleeping = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let rabbit = &#123;</span><br><span class="line">  name: &quot;White Rabbit&quot;,</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 修改 rabbit.isSleeping</span><br><span class="line">rabbit.sleep();</span><br><span class="line"></span><br><span class="line">alert(rabbit.isSleeping); // true</span><br><span class="line">alert(animal.isSleeping); // undefined（原型中没有此属性）</span><br></pre></td></tr></table></figure><p>PS:</p><ul><li>方法是共享的，但对象是独立的</li><li>this只会取决于引用的对象</li></ul><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let animal = &#123;</span><br><span class="line">  eats: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let rabbit = &#123;</span><br><span class="line">  jumps: true,</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Object.keys 只返回自己的 key</span><br><span class="line">alert(Object.keys(rabbit)); // jumps</span><br><span class="line"></span><br><span class="line">// for..in 会遍历自己以及继承的键</span><br><span class="line">for(let prop in rabbit) alert(prop); // jumps，然后是 eats</span><br></pre></td></tr></table></figure><h4 id="过滤方法：object-hasOwnProperty（key）"><a href="#过滤方法：object-hasOwnProperty（key）" class="headerlink" title="过滤方法：object.hasOwnProperty（key）"></a>过滤方法：object.hasOwnProperty（key）</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let animal = &#123;</span><br><span class="line">  eats: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let rabbit = &#123;</span><br><span class="line">  jumps: true,</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(let prop in rabbit) &#123;</span><br><span class="line">  let isOwn = rabbit.hasOwnProperty(prop);</span><br><span class="line"></span><br><span class="line">  if (isOwn) &#123;</span><br><span class="line">    alert(`Our: $&#123;prop&#125;`); // Our: jumps</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert(`Inherited: $&#123;prop&#125;`); // Inherited: eats</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="F-prototype"><a href="#F-prototype" class="headerlink" title="F.prototype"></a>F.prototype</h3><p>​    函数的原型继承</p><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let animal = &#123;</span><br><span class="line">  eats: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Rabbit(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rabbit.prototype = animal;</span><br><span class="line"></span><br><span class="line">let rabbit = new Rabbit(&quot;White Rabbit&quot;); //  rabbit.__proto__ == animal</span><br><span class="line"></span><br><span class="line">alert( rabbit.eats ); // true</span><br></pre></td></tr></table></figure><p>PS:</p><ul><li>当没有原型指向时，指向自身</li><li>constructor为确保正确性可以默认设置</li></ul><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Rabbit() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 不要将 Rabbit.prototype 整个覆盖</span><br><span class="line">// 可以向其中添加内容</span><br><span class="line">Rabbit.prototype.jumps = true</span><br><span class="line">// 默认的 Rabbit.prototype.constructor</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rabbit.prototype = &#123;</span><br><span class="line">  jumps: true,</span><br><span class="line">  constructor: Rabbit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 这样的 constructor 也是正确的，因为我们手动添加了它</span><br></pre></td></tr></table></figure><h3 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h3><p>现象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">alert( obj ); // &quot;[object Object]&quot; ?</span><br></pre></td></tr></table></figure><p><img src="%E6%88%AA%E5%9B%BE/%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt="原生的原型"></p><p>解释：创建对象时，prototype指向的更大的对象中，含有tosting</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj.__proto__ === Object.prototype); // true</span><br><span class="line"></span><br><span class="line">alert(obj.toString === obj.__proto__.toString); //true</span><br><span class="line">alert(obj.toString === Object.prototype.toString); //true</span><br></pre></td></tr></table></figure><p>解释：在创建之初，就有prototype原型，但是在原型之上没有更多的原链（即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.__proto__); // null</span><br></pre></td></tr></table></figure><p>）</p><h4 id="其他内建原型"><a href="#其他内建原型" class="headerlink" title="其他内建原型"></a>其他内建原型</h4><p><img src="%E6%88%AA%E5%9B%BE/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1.png" alt="完整的内建对象"></p><p>完整的内建对象</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">// 它继承自 Array.prototype？</span><br><span class="line">alert( arr.__proto__ === Array.prototype ); // true</span><br><span class="line"></span><br><span class="line">// 接下来继承自 Object.prototype？</span><br><span class="line">alert( arr.__proto__.__proto__ === Object.prototype ); // true</span><br><span class="line"></span><br><span class="line">// 原型链的顶端为 null。</span><br><span class="line">alert( arr.__proto__.__proto__.__proto__ ); // null</span><br></pre></td></tr></table></figure><h4 id="显示继承"><a href="#显示继承" class="headerlink" title="显示继承"></a>显示继承</h4><p>console.dir（）</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>通过临时对象包装器进行创建</p><p>PS：null和undefined 没有对象包装器</p><h4 id="更改原生原型"><a href="#更改原生原型" class="headerlink" title="更改原生原型"></a>更改原生原型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.show = function() &#123;</span><br><span class="line">  alert(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&quot;BOOM!&quot;.show(); // BOOM!</span><br></pre></td></tr></table></figure><h4 id="※例子"><a href="#※例子" class="headerlink" title="※例子"></a>※例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (!String.prototype.repeat) &#123; // 如果这儿没有这个方法</span><br><span class="line">  // 那就在 prototype 中添加它</span><br><span class="line"></span><br><span class="line">  String.prototype.repeat = function(n) &#123;</span><br><span class="line">    // 重复传入的字符串 n 次</span><br><span class="line"></span><br><span class="line">    // 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）</span><br><span class="line">    // 但即使是不够完美的 polyfill 也常常被认为是足够好的</span><br><span class="line">    return new Array(n + 1).join(this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( &quot;La&quot;.repeat(3) ); // LaLaLa</span><br></pre></td></tr></table></figure><h4 id="原型借用"><a href="#原型借用" class="headerlink" title="原型借用"></a>原型借用</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  0: &quot;Hello&quot;,</span><br><span class="line">  1: &quot;world!&quot;,</span><br><span class="line">  length: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.join = Array.prototype.join;</span><br><span class="line"></span><br><span class="line">alert( obj.join(&#x27;,&#x27;) ); // Hello,world!</span><br></pre></td></tr></table></figure><h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><p>obj.__proto_方法在现代的应用中不推荐，进而取代的为</p><ul><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>。</p></li><li><p>[Object.create(proto, <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/create">descriptors])</a> —— 利用给定的 <code>proto</code> 作为 <code>[[Prototype]]</code> 和可选的属性描述来创建一个空对象。</p></li></ul><p>PS: proto作为属性是被允许的</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">et animal = &#123;</span><br><span class="line">  eats: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建一个以 animal 为原型的新对象</span><br><span class="line">let rabbit = Object.create(animal); // 与 &#123;__proto__: animal&#125; 相同</span><br><span class="line"></span><br><span class="line">alert(rabbit.eats); // true</span><br><span class="line"></span><br><span class="line">alert(Object.getPrototypeOf(rabbit) === animal); // true</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(rabbit, &#123;&#125;); // 将 rabbit 的原型修改为 &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="obj-create方法"><a href="#obj-create方法" class="headerlink" title="obj.create方法"></a>obj.create方法</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let animal = &#123;</span><br><span class="line">  eats: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let rabbit = Object.create(animal, &#123;</span><br><span class="line">  jumps: &#123;</span><br><span class="line">    value: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(rabbit.jumps); // true</span><br></pre></td></tr></table></figure><p>解释：类似于标志描述方式</p><p>应用：可用于完整的复制对象的所有属性（可枚举 不可枚举）</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let clone = Object.create(</span><br><span class="line">  Object.getPrototypeOf(obj),</span><br><span class="line">  Object.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="class语法"><a href="#class语法" class="headerlink" title="class语法"></a>class语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  // class 方法</span><br><span class="line">  constructor() &#123; ... &#125;</span><br><span class="line">  method1() &#123; ... &#125;</span><br><span class="line">  method2() &#123; ... &#125;</span><br><span class="line">  method3() &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用new myclass 进行创建上述对象 类似于new function</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用法：</span><br><span class="line">let user = new User(&quot;John&quot;);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure><h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>类方法之间不用添加逗号</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>在创建class时会调用constuctor方法初始化对象</p><h4 id="class-的解释"><a href="#class-的解释" class="headerlink" title="class 的解释"></a>class 的解释</h4><p>​    在JS中类是一种函数</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123; this.name = name; &#125;</span><br><span class="line">  sayHi() &#123; alert(this.name); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 佐证：User 是一个函数</span><br><span class="line">alert(typeof User); // function</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name) &#123; this.name = name; &#125;</span><br><span class="line">  sayHi() &#123; alert(this.name); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class 是一个函数</span><br><span class="line">alert(typeof User); // function</span><br><span class="line"></span><br><span class="line">// ...或者，更确切地说，是 constructor 方法</span><br><span class="line">alert(User === User.prototype.constructor); // true</span><br><span class="line"></span><br><span class="line">// 方法在 User.prototype 中，例如：</span><br><span class="line">alert(User.prototype.sayHi); // sayHi 方法的代码</span><br><span class="line"></span><br><span class="line">// 在原型中实际上有两个方法</span><br><span class="line">alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi</span><br></pre></td></tr></table></figure><h4 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let User = class &#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(&quot;Hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释：类似于函数表达式，可被传递，被返回，被赋值</p><p>PS:</p><p>类表达式的名字仅在内部可见</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// “命名类表达式（Named Class Expression）”</span><br><span class="line">// (规范中没有这样的术语，但是它和命名函数表达式类似)</span><br><span class="line">let User = class MyClass &#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(MyClass); // MyClass 这个名字仅在类内部可见</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new User().sayHi(); // 正常运行，显示 MyClass 中定义的内容</span><br><span class="line"></span><br><span class="line">alert(MyClass); // error，MyClass 在外部不可见</span><br></pre></td></tr></table></figure><h5 id="按需创建类（函数返回类表达式）"><a href="#按需创建类（函数返回类表达式）" class="headerlink" title="按需创建类（函数返回类表达式）"></a>按需创建类（函数返回类表达式）</h5><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function makeClass(phrase) &#123;</span><br><span class="line">  // 声明一个类并返回它</span><br><span class="line">  return class &#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">      alert(phrase);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个新的类</span><br><span class="line">let User = makeClass(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">new User().sayHi(); // Hello</span><br></pre></td></tr></table></figure><h4 id="getters-setters"><a href="#getters-setters" class="headerlink" title="getters setters"></a>getters setters</h4><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    // 调用 setter</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    if (value.length &lt; 4) &#123;</span><br><span class="line">      alert(&quot;Name is too short.&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    this._name = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = new User(&quot;John&quot;);</span><br><span class="line">alert(user.name); // John</span><br><span class="line"></span><br><span class="line">user = new User(&quot;&quot;); // Name is too short.</span><br></pre></td></tr></table></figure><h4 id="计算属性名称【…】"><a href="#计算属性名称【…】" class="headerlink" title="计算属性名称【…】"></a>计算属性名称【…】</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line"></span><br><span class="line">  [&#x27;say&#x27; + &#x27;Hi&#x27;]() &#123;</span><br><span class="line">    alert(&quot;Hello&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new User().sayHi();</span><br></pre></td></tr></table></figure><p>解释：类似于字符串的组合</p><h4 id="class-字段"><a href="#class-字段" class="headerlink" title="class 字段"></a>class 字段</h4><p> 类字段添加任何属性的语法</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  name = &quot;John&quot;;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(`Hello, $&#123;this.name&#125;!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new User().sayHi(); // Hello, John!</span><br></pre></td></tr></table></figure><p>解释：在class中添加属性只需要用等号“=”</p><h4 id="使用类字段制作绑定方法"><a href="#使用类字段制作绑定方法" class="headerlink" title="使用类字段制作绑定方法"></a>使用类字段制作绑定方法</h4><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Button &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  click = () =&gt; &#123;</span><br><span class="line">    alert(this.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let button = new Button(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(button.click, 1000); // hello</span><br></pre></td></tr></table></figure><p>解释：相比于包装函数，这种方法能够将this指定的对象带到任何地方</p><h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class child extends parent</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.speed = 0;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(speed) &#123;</span><br><span class="line">    this.speed = speed;</span><br><span class="line">    alert(`$&#123;this.name&#125; runs with speed $&#123;this.speed&#125;.`);</span><br><span class="line">  &#125;</span><br><span class="line">  stop() &#123;</span><br><span class="line">    this.speed = 0;</span><br><span class="line">    alert(`$&#123;this.name&#125; stands still.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = new Animal(&quot;My animal&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Rabbit extends Animal &#123;</span><br><span class="line">  hide() &#123;</span><br><span class="line">    alert(`$&#123;this.name&#125; hides!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let rabbit = new Rabbit(&quot;White Rabbit&quot;);</span><br><span class="line"></span><br><span class="line">rabbit.run(5); // White Rabbit runs with speed 5.</span><br><span class="line">rabbit.hide(); // White Rabbit hides!</span><br></pre></td></tr></table></figure><p>解释：查找原则是类似于继承：</p><ol><li>查找对象 <code>rabbit</code>（没有 <code>run</code>）。</li><li>查找它的原型，即 <code>Rabbit.prototype</code>（有 <code>hide</code>，但没有 <code>run</code>）。</li><li>查找它的原型，即（由于 <code>extends</code>）<code>Animal.prototype</code>，在这儿找到了 <code>run</code> 方法。</li></ol><p>PS：extends，类语法允许任何表达式</p><h4 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h4><p>​    不完全继承父类方法，但需要调用父类方法</p><ul><li>执行 <code>super.method(...)</code> 来调用一个父类方法。</li><li>执行 <code>super(...)</code> 来调用一个父类 constructor（只能在我们的 constructor 中）。</li></ul><ul><li>```<br>class Animal {  constructor(name) {<pre><code>this.speed = 0;this.name = name;</code></pre>  }  run(speed) {<pre><code>this.speed = speed;alert(`$&#123;this.name&#125; runs with speed $&#123;this.speed&#125;.`);</code></pre>  }  stop() {<pre><code>this.speed = 0;alert(`$&#123;this.name&#125; stands still.`);</code></pre>  }}class Rabbit extends Animal {<br>  hide() {<pre><code>alert(`$&#123;this.name&#125; hides!`);</code></pre>  }  stop() {<pre><code>super.stop(); // 调用父类的 stopthis.hide(); // 然后 hide</code></pre>  }<br>}let rabbit = new Rabbit(“White Rabbit”);rabbit.run(5); // White Rabbit runs with speed 5.<br>rabbit.stop(); // White Rabbit stands still. White Rabbit hides!<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 重写constructor</span><br><span class="line"></span><br><span class="line">如果在类继承另一个类时，自身没有设置constructor会生成空</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure>class Animal {<br>constructor(name) {<br>  this.speed = 0;<br>  this.name = name;<br>}<br>// …<br>}</li></ul><p>class Rabbit extends Animal {</p><p>  constructor(name, earLength) {<br>    this.speed = 0;<br>    this.name = name;<br>    this.earLength = earLength;<br>  }</p><p>  // …<br>}</p><p>// 不工作！<br>let rabbit = new Rabbit(“White Rabbit”, 10); // Error: this is not defined.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>class Animal {</p><p>  constructor(name) {<br>    this.speed = 0;<br>    this.name = name;<br>  }</p><p>  // …<br>}</p><p>class Rabbit extends Animal {</p><p>  constructor(name, earLength) {<br>    super(name);<br>    this.earLength = earLength;<br>  }</p><p>  // …<br>}</p><p>// 现在可以了<br>let rabbit = new Rabbit(“White Rabbit”, 10);<br>alert(rabbit.name); // White Rabbit<br>alert(rabbit.earLength); // 10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS: super一定在this引用前使用</span><br><span class="line"></span><br><span class="line">#### 重写类字段</span><br><span class="line"></span><br><span class="line">重写的方法大于继承的字段，重写的字段小于继承的字段</span><br><span class="line"></span><br><span class="line">### 静态属性和静态方法</span><br><span class="line"></span><br><span class="line">语法： static 方法</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>class User {<br>  static staticMethod() {<br>    alert(this === User);<br>  }<br>}</p><p>User.staticMethod(); // true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：将static 的方法整体作为属性赋值</span><br><span class="line"></span><br><span class="line">PS：静态方法属于整个class，不适用于单个对象</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// …<br>article.createTodays(); /// Error: article.createTodays is not a function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 静态属性</span><br><span class="line"></span><br><span class="line">语法：static 属性值（key）</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>class Article {<br>  static publisher = “Levi Ding”;<br>}</p><p>alert( Article.publisher ); // Levi Ding</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 继承静态属性和方法</span><br><span class="line"></span><br><span class="line">​静态属性和方法同样可以被继承 extends</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>class Animal {<br>  static planet = “Earth”;</p><p>  constructor(name, speed) {<br>    this.speed = speed;<br>    this.name = name;<br>  }</p><p>  run(speed = 0) {<br>    this.speed += speed;<br>    alert(<code>$&#123;this.name&#125; runs with speed $&#123;this.speed&#125;.</code>);<br>  }</p><p>  static compare(animalA, animalB) {<br>    return animalA.speed - animalB.speed;<br>  }</p><p>}</p><p>// 继承于 Animal<br>class Rabbit extends Animal {<br>  hide() {<br>    alert(<code>$&#123;this.name&#125; hides!</code>);<br>  }<br>}</p><p>let rabbits = [<br>  new Rabbit(“White Rabbit”, 10),<br>  new Rabbit(“Black Rabbit”, 5)<br>];</p><p>rabbits.sort(Rabbit.compare);</p><p>rabbits[0].run(); // Black Rabbit runs with speed 5.</p><p>alert(Rabbit.planet); // Earth</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 私有的和受保护的属性和方法</span><br><span class="line"></span><br><span class="line">#### 只读 power</span><br><span class="line"></span><br><span class="line">方法：仅设置getter 不设置setter</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>class CoffeeMachine {<br>  // …</p><p>  constructor(power) {<br>    this._power = power;<br>  }</p><p>  get power() {<br>    return this._power;<br>  }</p><p>}</p><p>// 创建咖啡机<br>let coffeeMachine = new CoffeeMachine(100);</p><p>alert(<code>Power is: $&#123;coffeeMachine.power&#125;W</code>); // 功率是：100W</p><p>coffeeMachine.power = 25; // Error（没有 setter）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 私有的 “#”</span><br><span class="line"></span><br><span class="line">私有属性用#开头，仅内部可访问</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>class CoffeeMachine {</p><p>  #waterAmount = 0;</p><p>  get waterAmount() {<br>    return this.#waterAmount;<br>  }</p><p>  set waterAmount(value) {<br>    if (value &lt; 0) value = 0;<br>    this.#waterAmount = value;<br>  }<br>}</p><p>let machine = new CoffeeMachine();</p><p>machine.waterAmount = 100;<br>alert(machine.#waterAmount); // Error</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以设置访问器</span><br><span class="line"></span><br><span class="line">#### 受保护的“_”</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>class CoffeeMachine {<br>  _waterAmount = 0;</p><p>  set waterAmount(value) {<br>    if (value &lt; 0) {<br>      value = 0;<br>    }<br>    this._waterAmount = value;<br>  }</p><p>  get waterAmount() {<br>    return this._waterAmount;<br>  }</p><p>  constructor(power) {<br>    this._power = power;<br>  }</p><p>}</p><p>// 创建咖啡机<br>let coffeeMachine = new CoffeeMachine(100);</p><p>// 加水<br>coffeeMachine.waterAmount = -10; // _waterAmount 将变为 0，而不是 -10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 类检查符</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>obj instanceof Class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">检查obj是否属于class类，或者衍生类，是则返回true</span><br><span class="line"></span><br><span class="line">#### Object.prototype.toString 方法来揭示类型</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 方便起见，将 toString 方法复制到一个变量中<br>let objectToString = Object.prototype.toString;</p><p>// 它是什么类型的？<br>let arr = [];</p><p>alert( objectToString.call(arr) ); // [object Array]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 错误处理</span><br><span class="line"></span><br><span class="line">### try... catch</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try {</p><p>  // 代码…</p><p>} catch (err) {</p><p>  // 错误捕获</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS:</span><br><span class="line"></span><br><span class="line">- err是一个对象</span><br><span class="line">- err可以不存在</span><br><span class="line">- try...catch 对错误编译无法使用，仅对逻辑错误可使用</span><br><span class="line"></span><br><span class="line">#### throw 操作符</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>throw <error object></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let json = ‘{ “age”: 30 }’; // 不完整的数据</p><p>try {</p><p>  let user = JSON.parse(json); // &lt;– 没有 error</p><p>  if (!user.name) {<br>    throw new SyntaxError(“数据不全：没有 name”); // (*)<br>  }</p><p>  alert( user.name );</p><p>} catch(err) {<br>  alert( “JSON Error: “ + err.message ); // JSON Error: 数据不全：没有 name<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 再次抛出</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">1. Catch 捕获所有 error。</span><br><span class="line">2. 在 `catch (err) &#123;...&#125;` 块中，我们对 error 对象 `err` 进行分析。</span><br><span class="line">3. 如果我们不知道如何处理它，那我们就 `throw err`。</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let json = ‘{ “age”: 30 }’; // 不完整的数据<br>try {</p><p>  let user = JSON.parse(json);</p><p>  if (!user.name) {<br>    throw new SyntaxError(“数据不全：没有 name”);<br>  }</p><p>  blabla(); // 预料之外的 error</p><p>  alert( user.name );</p><p>} catch (err) {</p><p>  if (err instanceof SyntaxError) {<br>    alert( “JSON Error: “ + err.message );<br>  } else {<br>    throw err; // 再次抛出 (*)<br>  }</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### try...catch...finally</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try {<br>   … 尝试执行的代码 …<br>} catch (err) {<br>   … 处理 error …<br>} finally {<br>   … 总是会执行的代码 …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>function func() {</p><p>  try {<br>    return 1;</p><p>  } catch (err) {<br>    /* … */<br>  } finally {<br>    alert( ‘finally’ );<br>  }<br>}</p><p>alert( func() ); // 先执行 finally 中的 alert，然后执行这个 alert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS：</span><br><span class="line"></span><br><span class="line">​catch可以不存在</span><br><span class="line"></span><br><span class="line">### 全局catch</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>window.onerror = function(message, url, line, col, error) {<br>  // …<br>};</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：函数将在发生未捕获的 error 时执行</span><br><span class="line"></span><br><span class="line">- message是err内容</span><br><span class="line">- UR1是err脚本的url</span><br><span class="line">- line，col是err所在行列号</span><br><span class="line">- err是错误对象</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><script>  window.onerror = function(message, url, line, col, error) {    alert(`${message}\n At ${line}:${col} of ${url}`);  };  function readData() {    badFunc(); // 啊，出问题了！  }  readData();</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 自定义error 扩展error</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>class ValidationError extends Error {<br>  constructor(message) {<br>    super(message); // (1)<br>    this.name = “ValidationError”; // (2)<br>  }<br>}</p><p>function test() {<br>  throw new ValidationError(“Whoops!”);<br>}</p><p>try {<br>  test();<br>} catch(err) {<br>  alert(err.message); // Whoops!<br>  alert(err.name); // ValidationError<br>  alert(err.stack); // 一个嵌套调用的列表，每个调用都有对应的行号<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Promise，async/await</span><br><span class="line"></span><br><span class="line">### 回调</span><br><span class="line"></span><br><span class="line">异步示例：</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>function loadScript(src) {<br>  // 创建一个 <script> 标签，并将其附加到页面<br>  // 这将使得具有给定 src 的脚本开始加载，并在加载完成后运行<br>  let script = document.createElement('script');<br>  script.src = src;<br>  document.head.append(script);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>loadScript(‘/my/script.js’);<br>// loadScript 下面的代码<br>// 不会等到脚本加载完成才执行<br>// …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### ※Promise</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise(function(resolve, reject) {<br>  // executor（生产者代码，“歌手”）<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS：</span><br><span class="line"></span><br><span class="line">- `resolve(value)` —— 如果任务成功完成并带有结果 `value`。</span><br><span class="line">- `reject(error)` —— 如果出现了 error，`error` 即为 error 对象。</span><br><span class="line"></span><br><span class="line">executor会执行其中一个方向，若失败调用则执行另一个方向</span><br><span class="line"></span><br><span class="line">promise返回对象具有的内部属性：</span><br><span class="line"></span><br><span class="line">- `state` —— 最初是 `&quot;pending&quot;`，然后在 `resolve` 被调用时变为 `&quot;fulfilled&quot;`，或者在 `reject` 被调用时变为 `&quot;rejected&quot;`。</span><br><span class="line">- `result` —— 最初是 `undefined`，然后在 `resolve(value)` 被调用时变为 `value`，或者在 `reject(error)` 被调用时变为 `error`。</span><br><span class="line"></span><br><span class="line">executor只会调用一个resolve和或reject</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise(function(resolve, reject) {<br>  resolve(“done”);</p><p>  reject(new Error(“…”)); // 被忽略<br>  setTimeout(() =&gt; resolve(“…”)); // 被忽略<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### then catch</span><br><span class="line"></span><br><span class="line">##### then(f,f)</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise.then(<br>  function(result) { /* handle a successful result <em>/ },<br>  function(error) { /</em> handle an error */ }<br>);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">`.then` 的第一个参数是一个函数，该函数将在 promise resolved 且接收到结果后执行。</span><br><span class="line"></span><br><span class="line">`.then` 的第二个参数也是一个函数，该函数将在 promise rejected 且接收到 error 信息后执行。</span><br><span class="line"></span><br><span class="line"> eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise(function(resolve, reject) {<br>  setTimeout(() =&gt; resolve(“done!”), 1000);<br>});</p><p>// resolve 运行 .then 中的第一个函数<br>promise.then(<br>  result =&gt; alert(result), // 1 秒后显示 “done!”<br>  error =&gt; alert(error) // 不运行<br>);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise(function(resolve, reject) {<br>  setTimeout(() =&gt; reject(new Error(“Whoops!”)), 1000);<br>});</p><p>// reject 运行 .then 中的第二个函数<br>promise.then(<br>  result =&gt; alert(result), // 不运行<br>  error =&gt; alert(error) // 1 秒后显示 “Error: Whoops!”<br>);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### catch</span><br><span class="line"></span><br><span class="line">只关注err时</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise((resolve, reject) =&gt; {<br>  setTimeout(() =&gt; reject(new Error(“Whoops!”)), 1000);<br>});</p><p>// .catch(f) 与 promise.then(null, f) 一样<br>promise.catch(alert); // 1 秒后显示 “Error: Whoops!”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### finally(f)</span><br><span class="line"></span><br><span class="line">于then的区别：</span><br><span class="line"></span><br><span class="line">1. `finally` 处理程序（handler）没有参数。在 `finally` 中，我们不知道 promise 是否成功。没关系，因为我们的任务通常是执行“常规”的完成程序（finalizing procedures）。</span><br><span class="line"></span><br><span class="line">   请看上面的例子：如你所见，`finally` 处理程序没有参数，promise 的结果由下一个处理程序处理。</span><br><span class="line"></span><br><span class="line">2. `finally` 处理程序将结果或 error “传递”给下一个合适的处理程序。</span><br><span class="line"></span><br><span class="line">3. `finally` 处理程序也不应该返回任何内容。如果它返回了，返回的值会默认被忽略。</span><br><span class="line"></span><br><span class="line">### Promise链</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>new Promise(function(resolve, reject) {</p><p>  setTimeout(() =&gt; resolve(1), 1000); // (*)</p><p>}).then(function(result) { // (**)</p><p>  alert(result); // 1<br>  return result * 2;</p><p>}).then(function(result) { // (***)</p><p>  alert(result); // 2<br>  return result * 2;</p><p>}).then(function(result) {</p><p>  alert(result); // 4<br>  return result * 2;</p><p>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![链](%E6%88%AA%E5%9B%BE/%E9%93%BE.png)</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line">非链</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise(function(resolve, reject) {<br>  setTimeout(() =&gt; resolve(1), 1000);<br>});</p><p>promise.then(function(result) {<br>  alert(result); // 1<br>  return result * 2;<br>});</p><p>promise.then(function(result) {<br>  alert(result); // 1<br>  return result * 2;<br>});</p><p>promise.then(function(result) {<br>  alert(result); // 1<br>  return result * 2;<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![非链](%E6%88%AA%E5%9B%BE/%E9%9D%9E%E9%93%BE.png)</span><br><span class="line"></span><br><span class="line">#### 返回promise</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>new Promise(function(resolve, reject) {</p><p>  setTimeout(() =&gt; resolve(1), 1000);</p><p>}).then(function(result) {</p><p>  alert(result); // 1</p><p>  return new Promise((resolve, reject) =&gt; { // (*)<br>    setTimeout(() =&gt; resolve(result * 2), 1000);<br>  });</p><p>}).then(function(result) { // (**)</p><p>  alert(result); // 2</p><p>  return new Promise((resolve, reject) =&gt; {<br>    setTimeout(() =&gt; resolve(result * 2), 1000);<br>  });</p><p>}).then(function(result) {</p><p>  alert(result); // 4</p><p>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 总结</span><br><span class="line"></span><br><span class="line">​如果 .then（或 catch/finally 都可以）处理程序返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。当它被 settled 后，其 result（或 error）将被进一步传递下去。</span><br><span class="line"></span><br><span class="line">![链流程图](%E6%88%AA%E5%9B%BE/%E9%93%BE%E6%B5%81%E7%A8%8B%E5%9B%BE.png)</span><br><span class="line"></span><br><span class="line">### promise进行错误处理</span><br><span class="line"></span><br><span class="line">eg：catch</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>fetch(‘/article/promise-chaining/user.json’)<br>  .then(response =&gt; response.json())<br>  .then(user =&gt; fetch(<code>https://api.github.com/users/$&#123;user.name&#125;</code>))<br>  .then(response =&gt; response.json())<br>  .then(githubUser =&gt; new Promise((resolve, reject) =&gt; {<br>    let img = document.createElement(‘img’);<br>    img.src = githubUser.avatar_url;<br>    img.className = “promise-avatar-example”;<br>    document.body.append(img);</p><pre><code>setTimeout(() =&gt; &#123;  img.remove();  resolve(githubUser);&#125;, 3000);</code></pre><p>  }))<br>  .catch(error =&gt; alert(error.message));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS：</span><br><span class="line"></span><br><span class="line">catch遇到err不是立马执行，而是在整个链后执行如then</span><br><span class="line"></span><br><span class="line">#### 隐式 try...catch</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>new Promise((resolve, reject) =&gt; {<br>  resolve(“ok”);<br>}).then((result) =&gt; {<br>  blabla(); // 没有这个函数<br>}).catch(alert); // ReferenceError: blabla is not defined</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 再次抛出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 执行流：catch -&gt; catch<br>new Promise((resolve, reject) =&gt; {</p><p>  throw new Error(“Whoops!”);</p><p>}).catch(function(error) { // (*)</p><p>  if (error instanceof URIError) {<br>    // 处理它<br>  } else {<br>    alert(“Can’t handle such error”);</p><pre><code>throw error; // 再次抛出此 error 或另外一个 error，执行将跳转至下一个 catch</code></pre><p>  }</p><p>}).then(function() {<br>  /* 不在这里运行 */<br>}).catch(error =&gt; { // (**)</p><p>  alert(<code>The unknown error has occurred: $&#123;error&#125;</code>);<br>  // 不会返回任何内容 =&gt; 执行正常进行</p><p>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 未处理的rejection</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>new Promise(function() {<br>  noSuchFunction(); // 这里出现 error（没有这个函数）<br>})<br>  .then(() =&gt; {<br>    // 一个或多个成功的 promise 处理程序<br>  }); // 尾端没有 .catch！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在浏览器中的处理，捕捉全局的err</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>window.addEventListener(‘unhandledrejection’, function(event) {<br>  // 这个事件对象有两个特殊的属性：<br>  alert(event.promise); // [object Promise] —— 生成该全局 error 的 promise<br>  alert(event.reason); // Error: Whoops! —— 未处理的 error 对象<br>});</p><p>new Promise(function() {<br>  throw new Error(“Whoops!”);<br>}); // 没有用来处理 error 的 catch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Promise API</span><br><span class="line"></span><br><span class="line">#### Promise.all</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = Promise.all(iterable);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let urls = [<br>  ‘<a href="https://api.github.com/users/iliakan&#39;">https://api.github.com/users/iliakan&#39;</a>,<br>  ‘<a href="https://api.github.com/users/remy&#39;">https://api.github.com/users/remy&#39;</a>,<br>  ‘<a href="https://api.github.com/users/jeresig&#39;">https://api.github.com/users/jeresig&#39;</a><br>];</p><p>// 将每个 url 映射（map）到 fetch 的 promise 中<br>let requests = urls.map(url =&gt; fetch(url));</p><p>// Promise.all 等待所有任务都 resolved<br>Promise.all(requests)<br>  .then(responses =&gt; responses.forEach(<br>    response =&gt; alert(<code>$&#123;response.url&#125;: $&#123;response.status&#125;</code>)<br>  ));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS：</span><br><span class="line"></span><br><span class="line">- 当promise.all中一个错误时，直接跳出，并返回错误的err</span><br><span class="line"></span><br><span class="line">- promise.all遵循顺序</span><br><span class="line"></span><br><span class="line">- 参数可以允许非promise常规值，如1  2  3等常数  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### Promise.allSettled</span><br><span class="line"></span><br><span class="line">- `&#123;status:&quot;fulfilled&quot;, value:result&#125;` 对于成功的响应，</span><br><span class="line">- `&#123;status:&quot;rejected&quot;, reason:error&#125;` 对于 error。</span><br><span class="line">- 对所有的参数进行操作，即全有或全无</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let urls = [<br>  ‘<a href="https://api.github.com/users/iliakan&#39;">https://api.github.com/users/iliakan&#39;</a>,<br>  ‘<a href="https://api.github.com/users/remy&#39;">https://api.github.com/users/remy&#39;</a>,<br>  ‘<a href="https://no-such-url&/#39;">https://no-such-url&#39;</a><br>];</p><p>Promise.allSettled(urls.map(url =&gt; fetch(url)))<br>  .then(results =&gt; { // (*)<br>    results.forEach((result, num) =&gt; {<br>      if (result.status == “fulfilled”) {<br>        alert(<code>$&#123;urls[num]&#125;: $&#123;result.value.status&#125;</code>);<br>      }<br>      if (result.status == “rejected”) {<br>        alert(<code>$&#123;urls[num]&#125;: $&#123;result.reason&#125;</code>);<br>      }<br>    });<br>  });</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[<br>  {status: ‘fulfilled’, value: …response…},<br>  {status: ‘fulfilled’, value: …response…},<br>  {status: ‘rejected’, reason: …error object…}<br>]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Promise.race</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = Promise.race(iterable);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Promise.race([<br>  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),<br>  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(“Whoops!”)), 2000)),<br>  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))<br>]).then(alert); // 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">只返回第一个settled的promise结果（或err）</span><br><span class="line"></span><br><span class="line">#### Promise.any</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = Promise.any(iterable);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">与 `Promise.race` 类似，区别在于 `Promise.any` 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回。如果给出的 promise 都 rejected，那么返回的 promise 会带有 [`AggregateError`](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/AggregateError) —— 一个特殊的 error 对象，在其 `errors` 属性中存储着所有 promise error。</span><br><span class="line"></span><br><span class="line">即返回第一个成功的值</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Promise.any([<br>  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(“Whoops!”)), 1000)),<br>  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 2000)),<br>  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))<br>]).then(alert); // 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Promise.resolve/reject</span><br><span class="line"></span><br><span class="line">##### Promise.resolve</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise(resolve =&gt; resolve(value));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">当一个函数被期望返回一个 promise 时，这个方法用于兼容性。（译注：这里的兼容性是指，我们直接从缓存中获取了当前操作的结果 `value`，但是期望返回的是一个 promise，所以可以使用 `Promise.resolve(value)` 将 `value` “封装”进 promise，以满足期望返回一个 promise 的这个需求。）</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let cache = new Map();</p><p>function loadCached(url) {<br>  if (cache.has(url)) {<br>    return Promise.resolve(cache.get(url)); // (*)<br>  }</p><p>  return fetch(url)<br>    .then(response =&gt; response.text())<br>    .then(text =&gt; {<br>      cache.set(url,text);<br>      return text;<br>    });<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Promise.reject</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let promise = new Promise((resolve, reject) =&gt; reject(error));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">使用给定 error 创建一个 rejected 的 promise</span><br><span class="line"></span><br><span class="line">### Promisification</span><br><span class="line"></span><br><span class="line">### 微任务</span><br><span class="line"></span><br><span class="line">#### 微任务队列</span><br><span class="line"></span><br><span class="line">规范：</span><br><span class="line"></span><br><span class="line">- 队列（queue）是先进先出的：首先进入队列的任务会首先运行。</span><br><span class="line">- 只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务。</span><br><span class="line"></span><br><span class="line">#### 未处理的rejection</span><br><span class="line"></span><br><span class="line">### asyns/await</span><br><span class="line"></span><br><span class="line">#### async</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>async function f() {<br>  return 1;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">​当放在函数前时，以这个返回值包装一个promise，类似于promise.resolve</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>async function f() {<br>  return 1;<br>}</p><p>f().then(alert); // 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">显示返回为：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>async function f() {<br>  return Promise.resolve(1);<br>}</p><p>f().then(alert); // 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### await</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>async function f() {</p><p>  let promise = new Promise((resolve, reject) =&gt; {<br>    setTimeout(() =&gt; resolve(“done!”), 1000)<br>  });</p><p>  let result = await promise; // 等待，直到 promise resolve (*)</p><p>  alert(result); // “done!”<br>}</p><p>f();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">​类似于暂停，但不占用CPU</span><br><span class="line"></span><br><span class="line">PS：</span><br><span class="line"></span><br><span class="line">- 不能在普通函数中使用，要在async的函数中使用</span><br><span class="line">- 现代浏览器在modules允许顶层await</span><br><span class="line"></span><br><span class="line">#### Error处理</span><br><span class="line"></span><br><span class="line">1. 如果有 error，就会抛出异常 —— 就像那里调用了 `throw error` 一样。</span><br><span class="line">2. 否则，就返回结果。</span><br><span class="line"></span><br><span class="line">## 模块</span><br><span class="line"></span><br><span class="line">### 模块简介</span><br><span class="line"></span><br><span class="line">#### 什么是模块</span><br><span class="line"></span><br><span class="line">​一个模块就是一个文件，一个脚本就是一个模块。</span><br><span class="line"></span><br><span class="line">​模块具有互相加载（export import）</span><br><span class="line"></span><br><span class="line">- `export` 关键字标记了可以从当前模块外部访问的变量和函数。</span><br><span class="line">- `import` 关键字允许从其他模块导入功能。</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 📁 sayHi.js<br>export function sayHi(user) {<br>  alert(<code>Hello, $&#123;user&#125;!</code>);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>// 📁 main.js<br>import { sayHi } from ‘./sayHi.js’;</p><p>alert(sayHi); // function…<br>sayHi(‘John’); // Hello, John!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">​带有export的函数变量可以在外部函数进行应用，在import引用当前模块后进行引用</span><br><span class="line"></span><br><span class="line">#### 模块核心功能</span><br><span class="line"></span><br><span class="line">- 始终使用use strict</span><br><span class="line">- 模块级作用域</span><br><span class="line"></span><br><span class="line">#### import.meta</span><br><span class="line"></span><br><span class="line">解释：返回对象包含当前对象的模块信息</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="module">  alert(import.meta.url); // 脚本的 URL  // 对于内联脚本来说，则是当前 HTML 页面的 URL</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 浏览器</span><br><span class="line"></span><br><span class="line">## Document</span><br><span class="line"></span><br><span class="line">### 浏览器环境、规格</span><br><span class="line"></span><br><span class="line">不同平台提供不同功能的环境，成为主机环境JS在浏览器中![img](https://uploader.shimo.im/f/NPFpaZXZaklpeZu2.jpg!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjY2OTc1MjcsImZpbGVHVUlEIjoiRWUzMk1HbTJSRFVQT1ZBMiIsImlhdCI6MTY2NjY5NzIyNywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo3NjA4NjM0MH0.ZvwKI0hLR2uiGE_JZUASIovnLZfJ6pT2EFixrFlETr0)</span><br><span class="line"></span><br><span class="line">#### 文档对象模型DOM</span><br><span class="line">document对象是问号的入口PS：针对css有cssom方法：document.body.style.background 获取背景颜色，更改背景颜色浏览器</span><br><span class="line">#### 对象模型BOM浏览器</span><br><span class="line">(主机环境)提供的用于处理文档之外的所有内容的其他对象</span><br><span class="line"></span><br><span class="line">### DOM树</span><br><span class="line"></span><br><span class="line">​每个html标签都是一个对象，标签内的文本也是一个对象</span><br><span class="line"></span><br><span class="line">​可用用js访问这些对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>document.body.style.background = ‘red’; // 将背景设置为红色</p><p>setTimeout(() =&gt; document.body.style.background = ‘’, 3000); // 恢复回去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 自动修正</span><br><span class="line"></span><br><span class="line">​如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</span><br><span class="line"></span><br><span class="line">### 遍历DOM</span><br><span class="line"></span><br><span class="line">​对DOM的所有操作都是从document开始</span><br><span class="line"></span><br><span class="line">​在最顶层的树节点可用作为document的属性来使用</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><html>` = `document.documentElement<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最顶层的 document 节点是 `document.documentElement`。这是对应 `&lt;html&gt;` 标签的 DOM 节点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><body>` = `document.body<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另一个被广泛使用的 DOM 节点是 `&lt;body&gt;` 元素 —— `document.body`。</span><br><span class="line"></span><br></pre></td></tr></table></figure><head>` = `document.head<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`&lt;head&gt;` 标签可以通过 `document.head` 访问。</span><br><span class="line"></span><br><span class="line">#### 子节点</span><br><span class="line"></span><br><span class="line">- **子节点（或者叫作子）** —— 对应的是直系的子元素。换句话说，它们被完全嵌套在给定的元素中。例如，`&lt;head&gt;` 和 `&lt;body&gt;` 就是 `&lt;html&gt;` 元素的子元素。</span><br><span class="line">- **子孙元素** —— 嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。</span><br><span class="line">- childNodes：集合列出所有子节点</span><br><span class="line">- firstChild：第一个子节点</span><br><span class="line">- lastChild：最后一个子节点</span><br><span class="line"></span><br><span class="line">#### DOM集合</span><br><span class="line"></span><br><span class="line">​childNodes是一个类数组的可迭代对象，其重要的两个结果：</span><br><span class="line"></span><br><span class="line">- 可用for...of迭代</span><br><span class="line">- 无法使用数组方法，因为其不是一个数组</span><br><span class="line"></span><br></pre></td></tr></table></figure>不可行:alert(document.body.childNodes.filter); // undefined（这里没有 filter 方法！）创建数组：<p>alert( Array.from(document.body.childNodes).filter ); // function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 特点</span><br><span class="line"></span><br><span class="line">- DOM集合是只读的</span><br><span class="line">- DOM集合是实时的</span><br><span class="line">- 不要使用for...in遍历</span><br><span class="line"></span><br><span class="line">#### 兄弟节点和父节点</span><br><span class="line"></span><br><span class="line">访问下一个兄弟节点：nextSibling</span><br><span class="line"></span><br><span class="line">访问上一个兄弟节点：previousSibling</span><br><span class="line"></span><br><span class="line">访问父节点：parentNode</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// <body> 的父节点是 <html><br>alert( document.body.parentNode === document.documentElement ); // true</p><p>// <head> 的后一个是 <body><br>alert( document.head.nextSibling ); // HTMLBodyElement</p><p>// <body> 的前一个是 <head><br>alert( document.body.previousSibling ); // HTMLHeadElement</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 搜索：getElement*，querySelector</span><br><span class="line"></span><br><span class="line">#### document.getElementById </span><br><span class="line"></span><br></pre></td></tr></table></figure><div id="elem">  <div id="elem-content">Element</div></div><script>  // 获取该元素  let elem = document.getElementById('elem');  // 将该元素背景改为红色  elem.style.background = 'red';</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS：</span><br><span class="line"></span><br><span class="line">- id必须是唯一的</span><br><span class="line">- 没有anyelem.getElementById</span><br><span class="line"></span><br><span class="line">#### querySelectorAll（css）</span><br><span class="line"></span><br><span class="line">​返回CSS中所有的元素</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul>  <li>The</li>  <li>test</li></ul><ul>  <li>has</li>  <li>passed</li></ul><script>  let elements = document.querySelectorAll('ul > li:last-child');<p>  for (let elem of elements) {<br>    alert(elem.innerHTML); // “test”, “passed”<br>  }<br></script></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​返回每一个ul的最后一个li</span><br><span class="line"></span><br><span class="line">#### querySelector（css）</span><br><span class="line"></span><br><span class="line">​类同于：elem.querySelectorAll(css)[0]</span><br><span class="line"></span><br><span class="line">​寻找第一个CSS元素，相交于...All 这个方法更快</span><br><span class="line"></span><br><span class="line">#### matches</span><br><span class="line"></span><br><span class="line">​它只会检查 `elem` 是否与给定的 CSS 选择器匹配。它返回 `true` 或 `false`。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://example.com/file.zip">…</a><br><a href="http://ya.ru">…</a></p><script>  // 不一定是 document.body.children，还可以是任何集合  for (let elem of document.body.children) {    if (elem.matches('a[href$="zip"]')) {      alert("The archive reference: " + elem.href );    }  }</script><pre><code>只会返回第一个链接</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS稿</title>
      <link href="/shengeyan/2022/082164533.html"/>
      <url>/shengeyan/2022/082164533.html</url>
      
        <content type="html"><![CDATA[<h1 id="查阅文档"><a href="#查阅文档" class="headerlink" title="查阅文档"></a>查阅文档</h1><ul><li><a href="https://www.w3school.com.cn/">W3school</a></li><li><a href="https://developer.mozilla.org/zh-CN/">MDN</a></li></ul><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>shift+alt  全拉</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><p>​    html没有注重外观设计</p><p>​    css也是一种标记语言，叠层样式表，设置html中的内容</p><h2 id="css语法规范"><a href="#css语法规范" class="headerlink" title="css语法规范"></a>css语法规范</h2><p>​    选择器{xxx：xxx；xxx：xxx；}</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><p>​            标签选择器：语法：标签{属性：属性值；}</p><p>​            类选择器：语法：.类名（可自取）{属性：属性值；}</p><p>​            PS:</p><p>​            .red{color:red;}</p><p>​            li class=”red”&gt;红色&lt;li</p><p>​            （可多类一起用）</p><p>​            id选择器：语法：#id{属性：属性值；}</p><p>​            PS:</p><p>​            #red{color:red;}</p><p>​            div id=”red”&gt;&lt;/div</p><p>​            (只能调用一次)</p><p>​            通配符选择器：语法：*{属性：属性值；}</p><p>​            （所有标签）</p><h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>​                语法：标签{font-family:‘微软雅黑’；}（单引号双引号都可以）</p><h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>​                语法：标签{font-size：20px；}（标题标签需要单独指定）</p><h4 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h4><p>​                语法：标签{font-weight：bold；}（bold可以写为700  不用加单位）</p><p>​                PS:</p><p>​                正常 400 加粗 700  范围100-900</p><h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p>​                语法：标签{font-style：属性值；}（normal正常；italic倾斜）</p><h4 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h4><p>​                语法：标签{font：font-style font-weight font-size/font-height font-family}</p><p>​                （节约代码）</p><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><h4 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h4><p>​                语法：预定义，十六进制，rgb</p><h4 id="对齐文本"><a href="#对齐文本" class="headerlink" title="对齐文本"></a>对齐文本</h4><p>​                语法：标签{text-align：center；}（left，center，right）</p><h4 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h4><p>​                语法：标签{text-decoration：none}（underline，line-through删除线，overline）</p><h3 id="emmet语法"><a href="#emmet语法" class="headerlink" title="emmet语法"></a>emmet语法</h3><p>​                快速生成html css</p><p>语法：</p><pre><code>     生成html</code></pre><p>​        输入标签名 +tab</p><p>​        div*10 快速生成多个标签</p><p>​        父子级标签：ul&gt;li</p><p>​        兄弟关系标签：div+p</p><p>​        带类名或者id名 直接写.demo或者#two</p><p>​        序号排序   .demo$*5 $自增符号</p><p>​        生成内容默认显示 div{内容}</p><p>​        生成css：</p><p>​            简写如 w200  宽度200</p><h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p>​        右键：格式化文档</p><p>自动格式化代码：</p><p>​        首选项→设置→emment.include→setting.json→添加：</p><p>​        “editor.formatOnType”：true，</p><p>​        “editor.formatOnSave”：true，</p><h3 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h3><p>多个选择器组合为复合选择器</p><h4 id="后代选择器（重要）"><a href="#后代选择器（重要）" class="headerlink" title="后代选择器（重要）"></a>后代选择器（重要）</h4><p>​        语法：</p><p>​            元素1 元素2 {  样式声明 } ps：元素之间用空格隔开</p><p>​            多个相同时可以加类名</p><h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p>​        语法：</p><p>​            元素1&gt;元素2 {样式声明} ps：只会选择下一级 用&gt;隔开</p><h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><p>​        语法：</p><p>​        元素1，元素2 {样式声明} ps：最后一组不需要加逗号</p><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><h5 id="链接伪类"><a href="#链接伪类" class="headerlink" title="链接伪类"></a>链接伪类</h5><p>​        语法：</p><p>​        a：link 未被访问链接</p><p>​        a：visited 已访问</p><p>​        a：hover 鼠标所在链接 未按下</p><p>​        a：active 活动链接 按下未松开（长按）</p><p>注意事项：</p><p>​        顺序：link visited hover active</p><p>​        链接单独指定样式</p><h5 id="：focus-伪类选择器"><a href="#：focus-伪类选择器" class="headerlink" title="：focus 伪类选择器"></a>：focus 伪类选择器</h5><p>​        获取焦点的表单元素</p><p>​        语法：</p><p>​            input：focus {样式声明} </p><h1 id="CSS元素显示模式"><a href="#CSS元素显示模式" class="headerlink" title="CSS元素显示模式"></a>CSS元素显示模式</h1><p>元素以什么样的方式进行显示</p><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>特点;</p><p>独占一行</p><p>高度，宽度，边距可以控制</p><p>宽度默认父级宽度</p><p>容器 可以放其他元素</p><p>ps：</p><p>文字元素内不能放其他元素</p><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>特点：</p><p>一行可以显示多个</p><p>高度，宽度设置无效</p><p>默认宽度为本身宽度</p><p>只能容纳文本或者其他行内元素</p><p>ps：</p><p>链接内不能放链接</p><p>a&gt;内可以放块元素</p><h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3><p>特点：</p><p>一行可以有多个</p><p>默认宽度为本身宽度</p><p>高度，宽度等均可设置</p><h3 id="显示模式转换"><a href="#显示模式转换" class="headerlink" title="显示模式转换"></a>显示模式转换</h3><p>语法：</p><p>display：block；行转块</p><p>display：inline；块转行</p><p>display：inline-block；转行内块</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>snipaste</p><h3 id="单行文字垂直居中"><a href="#单行文字垂直居中" class="headerlink" title="单行文字垂直居中"></a>单行文字垂直居中</h3><p>文字高=盒子高</p><p>line-height：***px；</p><h1 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h1><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>background-color：transparent 透明</p><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>相对于图片：便于控制位置</p><p>background-image：none| url（）</p><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><p>background-repeat：repeat|no-repeat|repeat-x|repeat-y </p><p>平铺|不平铺|沿x轴平铺|沿y轴平铺</p><p>ps：背景图片压住背景颜色</p><h3 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h3><p>background-position：x y； 方位名词 或者 百分数</p><p>background-position：top left；跟顺序无关 无变量默认垂直居中</p><p>background-position：20px 50px；精确单位</p><p>background-position：top 50px；混合单位</p><h3 id="背景固定"><a href="#背景固定" class="headerlink" title="背景固定"></a>背景固定</h3><p>background-attachment：scroll|fixed 滚动|固定</p><h3 id="背景复合写法"><a href="#背景复合写法" class="headerlink" title="背景复合写法"></a>背景复合写法</h3><p>background：背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置；</p><h3 id="背景色半透明"><a href="#背景色半透明" class="headerlink" title="背景色半透明"></a>背景色半透明</h3><p>background：rgba（0,0,0,0）；</p><h1 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h1><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>样式重复冲突 后者覆盖前者（仅覆盖冲突部分）</p><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>div&gt;p 对div设置同时对p设置</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>选择器相同 层叠性</p><p>ID（0100）&gt;类（0010）&gt;元素（0001）&gt;继承（0000）</p><p>！important  最重要 权重最高</p><p>ps：</p><p>继承权重为0（父元素权重跟子元素无关）</p><h3 id="权重叠加"><a href="#权重叠加" class="headerlink" title="权重叠加"></a>权重叠加</h3><p>正常的权重相加即可</p><h1 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h1><h3 id="border-边框"><a href="#border-边框" class="headerlink" title="border 边框"></a>border 边框</h3><p>border-width：**px；粗细</p><p>border-style：solid（实线边框）|dashed（虚线边框）|dotted（点线）；样式</p><p>border-color：；</p><p>复合写法：</p><p>border：width style color；（没有顺序）</p><p>border-top（只改上边框）</p><p>border-bottom（只改下边框）</p><p>可层叠</p><p>border-collapse：；合并重合边框</p><h3 id="content-内容"><a href="#content-内容" class="headerlink" title="content 内容"></a>content 内容</h3><p>padding 内边距（边框和内容的间距）</p><p>padding-left（距离左边距）</p><p>复合写法：</p><p>padding：1 2 3 4；</p><p>一个值 上下左右</p><p>两个值  上下 左右</p><p>三个值 上  左右   下</p><p>四个值    上  右  下 左</p><p>ps：</p><p>padding 不撑开盒子的情况：没有指定宽度</p><h3 id="margin-外边距"><a href="#margin-外边距" class="headerlink" title="margin 外边距"></a>margin 外边距</h3><p>margin-bottom：20px；下边距</p><p>复合写法：</p><p>同padding相同</p><h4 id="水平居中："><a href="#水平居中：" class="headerlink" title="水平居中："></a>水平居中：</h4><p>必须要有width</p><p>左右设置为 auto</p><p>margin：0 auto；</p><h4 id="嵌套块元素塌陷"><a href="#嵌套块元素塌陷" class="headerlink" title="嵌套块元素塌陷"></a>嵌套块元素塌陷</h4><p>div&gt;（给父级添加边框  定义上边框  加 overflow：hidden）</p><p>​        div&gt;</p><p>​        &lt;/div</p></div### 清除内外边距<p>*{padding:0;margin:0;}</p><h3 id="除去无序列表钱的小圆点"><a href="#除去无序列表钱的小圆点" class="headerlink" title="除去无序列表钱的小圆点"></a>除去无序列表钱的小圆点</h3><p>lise-style：none；</p><h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><p>语法：</p><p>border-radius：length数值；数值越大弧度越大，也可以是百分比</p><p>如果有四个值 则为 左上  右上 右下 左下</p><p>border-top-left-radius</p><h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><p>语法：</p><p>box-shadow：水平  垂直   模糊距离  阴影尺寸 阴影颜色  内外阴影 intset不写就是外阴影；</p><p>经过加阴影</p><p>div：hover {样式}；</p><h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><p>语法;</p><p>text-shadow:水平  垂直 距离 颜色；</p><h1 id="CSS浮动"><a href="#CSS浮动" class="headerlink" title="CSS浮动"></a>CSS浮动</h1><h3 id="传统网页的三种布局方式"><a href="#传统网页的三种布局方式" class="headerlink" title="传统网页的三种布局方式"></a>传统网页的三种布局方式</h3><p>普通流：标签默认规定好  基本</p><p>浮动：多个标签一行表示</p><p>定位</p><p>ps：</p><p>纵向标准，横向浮动</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>语法：</p><p>选择器 {float：描述；} left right  none</p><h3 id="浮动特性-（重点）"><a href="#浮动特性-（重点）" class="headerlink" title="浮动特性 （重点）"></a>浮动特性 （重点）</h3><p>会脱离标准流  不保留原来的位置</p><p>多个浮动  顶端一行对齐</p><p>具有行内块元素特性</p><p>操作：</p><p>先准备父盒子，在准备子盒子</p><h3 id="常见网页布局"><a href="#常见网页布局" class="headerlink" title="常见网页布局"></a>常见网页布局</h3><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>为什么：父盒子没给高度  子盒子浮动 父盒子为0</p><p>本质：清除浮动造成的影响</p><p>语法；</p><p>选择器 {clear：属性值} left right both</p><h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><h4 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h4><p>末位后面加一个标签   必须是块级元素</p><h4 id="父级添加overflow"><a href="#父级添加overflow" class="headerlink" title="父级添加overflow"></a>父级添加overflow</h4><h4 id="after-伪元素-（父元素）"><a href="#after-伪元素-（父元素）" class="headerlink" title="after 伪元素 （父元素）"></a>after 伪元素 （父元素）</h4><p>.类名：after：{</p><p>content=“ ”；</p><p>display：block；</p><p>height：0；</p><p>clear：both；</p><p>visibility：hidden；</p><p>}</p><p>.类名 {</p><p>*zoom：1；</p><p>}（ie 6  7专有）</p><h4 id="双伪元素清除浮动（父元素添加）"><a href="#双伪元素清除浮动（父元素添加）" class="headerlink" title="双伪元素清除浮动（父元素添加）"></a>双伪元素清除浮动（父元素添加）</h4><p>.类名：before ，.类名：after {</p><p>content：“ ”；</p><p>display：table；</p><p>}</p><p>.类名：after {</p><p>clear：both；</p><p>}</p><p>*zoom：1；</p><p>}（ie 6  7专有）</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h3 id="常见图片格式"><a href="#常见图片格式" class="headerlink" title="常见图片格式"></a>常见图片格式</h3><p>JPG：产品类 </p><p>GIF：动画效果</p><p>PNG：透明图片 </p><p>PSD：ps 网页设计稿</p><h3 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h3><p>导出</p><p>切片工具</p><p>切片插件：cutterman</p><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h3 id="定位组成"><a href="#定位组成" class="headerlink" title="定位组成"></a>定位组成</h3><p>定位=定位模式+边偏移</p><p>语法：</p><p>定位模式：</p><p>position：属性值； static 静态定位，relative 相对定位 absolute 绝对定位 fixed 固定定位</p><p>边位移：</p><p>top：;</p><p>bottom: ;</p><p>left：；</p><p>right：；</p><h3 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h3><p>选择器 {position：；}</p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>相对于自己原来位置，会保留原来的位置</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>相对于祖元素</p><p>父元素没有或者没有定位：以浏览器为准</p><p>父元素有定位：则以父元素最近的为准</p><p>不占有位置</p><p>子绝父相</p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>以浏览器可视窗口为准</p><p>不占有原来位置  脱标</p><p>小技巧：</p><p>固定到版心右侧</p><h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><p>sticky</p><p>以浏览器可视窗口为准</p><p>必须添加 top  left right bottom 的一个</p><h3 id="定位叠放次序"><a href="#定位叠放次序" class="headerlink" title="定位叠放次序"></a>定位叠放次序</h3><p>z-index：值；  值越大越上</p><p>没有设置或者值相同  后来者在上</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>加了绝对定位的盒子 不能加maigin</p><p>行内元素添加了绝对和固定，可以设置高度和宽度</p><p>块级元素添加绝对和相对，不给宽度或者高度，则会是内容大小</p><p>浮动元素不会压住标准流文字定位</p><h3 id="显示影藏元素"><a href="#显示影藏元素" class="headerlink" title="显示影藏元素"></a>显示影藏元素</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>display：none；影藏</p><p>不占有原来的位置</p><p>display：block；显示</p><h4 id="bisibility"><a href="#bisibility" class="headerlink" title="bisibility"></a>bisibility</h4><p>bisibility：visible；可视 </p><p>bisibility：hidden；隐藏  继续占有原来的位置</p><p>bisibility：none；隐藏  不占用来的位置</p><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>溢出</p><p>visible  不剪切也不添加滚动条  默认</p><p>hidden  隐藏多出来的</p><p>scroll  溢出显示滚动条  不溢出也显示滚动条</p><p>auto  需要时添加滚动条</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML稿</title>
      <link href="/shengeyan/2022/08212417.html"/>
      <url>/shengeyan/2022/08212417.html</url>
      
        <content type="html"><![CDATA[<ul><li>html是一种标记语言</li></ul><h1 id="web标准的构成："><a href="#web标准的构成：" class="headerlink" title="web标准的构成："></a>web标准的构成：</h1><p>结构：对网页元素进行整理</p><p>表现：设置网页元素格式 CSS</p><p>行为：交互 JS</p><h1 id="HMTL标签"><a href="#HMTL标签" class="headerlink" title="HMTL标签"></a>HMTL标签</h1><html></html><br /><head>包含关系    <title></title></head><p>包含或并列关系</p><p>插件：</p><p>open in brown</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>段落 <h1></h1></p><p>换行<br/></p><p>标题<h1></h1></p><p>加粗<strong></strong>  <b></b></p><p>倾斜<em></em> <i></i></p><p>删除线<del></del> <s></s></p><p>下划线<ins></ins>  <u></u></p><h1 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h1><p>盒子<div></div></p><p>​        <span></span></p><p>图像<img src="图像url" /></p><p>​                    width</p><p>​                    height</p><p>​                    border</p><p>​                    alt </p><p>​                    title</p><p>超链接 <a></p><p>&lt;a href=”跳转目标” @target=”弹出方式”&gt; 文本</a></p><p>跳转：href=“#id”</p><p>​        id=“ ”</p><p>注释：<!-- --></p><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><h3 id="表格标签-1"><a href="#表格标签-1" class="headerlink" title="表格标签"></a>表格标签</h3><p>​    展示数据(语法如下)  &lt;嵌套原理&gt;</p><p>​        table  //定义表格标签</p><p>​            tr  //行     </p><p>​                td   文字  /td  //单元格   （td可用th  th具有居中加粗效果）</p><p>​                …</p><p>​            /tr</p><p>​                …</p><p>​        /table</p><h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p>ailgn              left，center，right    对齐方式</p><p>border          1或“ ”                            是否有边框</p><p>cellpadding  像素值                          单元边沿与内容间空白</p><p>cellspacing   像素值                          单元格间的空白</p><p>width            像素值或者百分比       宽度</p><h3 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h3><p>语法如下：</p><p>​    头部标签</p><p> thead</p><p>…</p><p>/thead</p><p>​    主体标签</p><p>tbody</p><p>…</p><p>/tbody</p><h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>语法如下：</p><p>​    跨行合并： rowspan=“个数”</p><p>​    跨列合并： colspan=“个数”</p><p>目标单元格：</p><p>​    跨行：最上栅单元格为目标单元格，写合并代码</p><p>​    跨列：最左侧单元格为目标单元格，写合并代码</p><p>​    多的删除</p><h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><h3 id="列表标签-1"><a href="#列表标签-1" class="headerlink" title="列表标签"></a>列表标签</h3><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>语法如下：</p><p>//  ul：无序列表  li：定义列表项</p><p>​    ul</p><p>​        li    列表1    /li</p><p>​    /ul</p><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法如下;</p><p>​    ol</p><p>​        li  列表1 /li</p><p>​    /ol    </p><h5 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h5><p>语法如下：</p><p>​    dl</p><p>​        dt 名词 /dt</p><p>​        dd 名词解释1 /dd</p><p>​    dl</p><h5 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h5><p>组成：表单域，表单控件（元素) ，提示信息</p><p>表单域：</p><p>​    form action=“ URL ” method=“提交方式”  name=“表单域名称”   //提交方式有get或者post</p><p>​    /form</p><p>表单控件：</p><p>​    input   输入表单元素    单标签</p><p>​        input type=”属性值（外观） “  name=”// 单选按钮必须取同一个名字 “ value=”属性值”  checked=””  maxlength=”” /</p><p>​    提交按钮</p><p>input type=”submit“ valve=“免费注册”</p><p>​    select  下拉表单元素</p><p>​        select</p><p>​            option&gt;选项1&lt;/option</p><p>​        /select</p><p>​        // 在option中定义selected=“selected”  默认选中</p><p>​    textarea  文本域元素</p><p>​        textarea rows=”3” cols=”20”&gt;</p><p>​                文本内容</p><p>​        /textarea&gt;</p><p>​        </p><h5 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h5><p>（标注标签）绑定一个表单元素 增加用户体验</p><p>语法如下;</p><p>​    label for=”sex”&gt;男&lt;/label</p><p>​    input type=”radio” name=”sex” id=”sex”/&gt;  //for 属性等于id属性</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的插件&amp;网站</title>
      <link href="/shengeyan/2022/032358922.html"/>
      <url>/shengeyan/2022/032358922.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo的插件-amp-网站"><a href="#hexo的插件-amp-网站" class="headerlink" title="hexo的插件&amp;网站"></a>hexo的插件&amp;网站</h1><h2 id="image-upload"><a href="#image-upload" class="headerlink" title="image upload"></a>image upload</h2><p>一个可以将本地图片上传到网上并存储，简单得到url的一个网站 <a href="https://sm.ms/">image upload</a></p><h2 id="leancloud"><a href="#leancloud" class="headerlink" title="leancloud"></a>leancloud</h2><p>为hexo安装上评论效果的插件，评论会自动同步到该网站，可以进行管理<a href="https://www.leancloud.cn/">leancloud</a></p><h2 id="来必力（livere）"><a href="#来必力（livere）" class="headerlink" title="来必力（livere）"></a>来必力（livere）</h2><p>一个外网的评论插件网站，进入该网站可能被墙，进入申请的到url复制到hexo的修改文件中，具体操作可以网上查询<a href="https://livere.com/">来必力</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFC</title>
      <link href="/shengeyan/2022/030817794.html"/>
      <url>/shengeyan/2022/030817794.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/03/07/gHk2zovsmKJyfY8.jpg" alt="CFC"></p><p>感谢给予的高度评价！</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建立个人博客</title>
      <link href="/shengeyan/2022/030149028.html"/>
      <url>/shengeyan/2022/030149028.html</url>
      
        <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li><p>准备一个gitee（码云）或github账号</p><p><a href="https://gitee.com/">gitee</a></p><p><a href="https://github.com/">github</a></p><p><img src="https://s2.loli.net/2022/03/06/Ghv2WcXQMwFo8UZ.png" alt="gitee"></p></li></ul><p><img src="https://s2.loli.net/2022/03/06/fpHltgxn5rwPkh6.png" alt="github"></p><ul><li>并在账号下注册仓库(个人设置内)</li></ul><ul><li><p>安装<a href="https://nodejs.org/zh-cn/download/">nodejs</a></p><p>详细<a href="%5Bhttps://blog.csdn.net/weixin_44893902/article/details/121788104?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164609517116780269856876%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164609517116780269856876&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121788104.pc_search_result_control_group&utm_term=nodejs%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187%5D(https://blog.csdn.net/weixin_44893902/article/details/121788104?ops_request_misc=%7B%22request_id%22:%22164609517116780269856876%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164609517116780269856876&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121788104.pc_search_result_control_group&utm_term=nodejs%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187)">安装教程</a> (注意计算机环境的配置)</p></li><li><p>安装<a href="https://www.npmjs.com/">npm</a>(有版本node含有npm)</p></li><li><p>安装<a href="https://git-scm.com/downloads">git</a>  (类似cmd)</p><p>git<a href="%5Bhttps://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164609601616780269848368%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164609601616780269848368&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115693833.pc_search_result_control_group&utm_term=git%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187%5D(https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%7B%22request_id%22:%22164609601616780269848368%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164609601616780269848368&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115693833.pc_search_result_control_group&utm_term=git%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187)">安装教程</a> </p></li><li><p>安装<a href="%E6%B7%98%E5%AE%9D%E4%BA%91">cnpm</a>（因为npm国内下载慢且容易失败，可以准备镜像）</p><p> 用git进行cnpm的安装：</p><p>输入以下命令：npm install -g cnpm -registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></li><li><p>安装hexo</p></li></ul><h1 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h1><ul><li><p>检查nodejs，npm，cnpm，hexo</p><p>输入以下命令：</p><p>node -v</p><p>npm -v</p><p>cnpm -v</p><p>hexo -v</p><p>git -v</p></li></ul><p>出现了版本号即成功安装</p><ul><li><p>检查本地部署情况</p><p>启动hexo：hexo s</p><p>（出现<a href="http://localhost:4000时即是本地博客建立成功）">http://localhost:4000时即是本地博客建立成功）</a></p></li></ul><h1 id="博客个性设置"><a href="#博客个性设置" class="headerlink" title="博客个性设置"></a>博客个性设置</h1><p><a href="https://blog.csdn.net/jspnetcn/article/details/104111651">按教程进行设置即可</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/shengeyan/2022/021616107.html"/>
      <url>/shengeyan/2022/021616107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
